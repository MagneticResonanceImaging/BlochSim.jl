<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · BlochSim.jl</title><meta name="title" content="Methods · BlochSim.jl"/><meta property="og:title" content="Methods · BlochSim.jl"/><meta property="twitter:title" content="Methods · BlochSim.jl"/><meta name="description" content="Documentation for BlochSim.jl."/><meta property="og:description" content="Documentation for BlochSim.jl."/><meta property="twitter:description" content="Documentation for BlochSim.jl."/><meta property="og:url" content="https://MagneticResonanceImaging.github.io/BlochSim.jl/stable/methods/"/><meta property="twitter:url" content="https://MagneticResonanceImaging.github.io/BlochSim.jl/stable/methods/"/><link rel="canonical" href="https://MagneticResonanceImaging.github.io/BlochSim.jl/stable/methods/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BlochSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Methods-list"><span>Methods list</span></a></li><li><a class="tocitem" href="#Methods-usage"><span>Methods usage</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/01-overview/">bSSFP</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MagneticResonanceImaging/BlochSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/main/docs/src/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Methods-list"><a class="docs-heading-anchor" href="#Methods-list">Methods list</a><a id="Methods-list-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-list" title="Permalink"></a></h2><ul><li><a href="#BlochSim.GAMBAR"><code>BlochSim.GAMBAR</code></a></li><li><a href="#BlochSim.GAMMA"><code>BlochSim.GAMMA</code></a></li><li><a href="#BlochSim.AbstractRF"><code>BlochSim.AbstractRF</code></a></li><li><a href="#BlochSim.AbstractSpin"><code>BlochSim.AbstractSpin</code></a></li><li><a href="#BlochSim.AbstractSpoiling"><code>BlochSim.AbstractSpoiling</code></a></li><li><a href="#BlochSim.BlochDynamicsMatrix"><code>BlochSim.BlochDynamicsMatrix</code></a></li><li><a href="#BlochSim.BlochMatrix"><code>BlochSim.BlochMatrix</code></a></li><li><a href="#BlochSim.BlochMcConnellDynamicsMatrix"><code>BlochSim.BlochMcConnellDynamicsMatrix</code></a></li><li><a href="#BlochSim.BlochMcConnellMatrix"><code>BlochSim.BlochMcConnellMatrix</code></a></li><li><a href="#BlochSim.ExchangeDynamicsMatrix"><code>BlochSim.ExchangeDynamicsMatrix</code></a></li><li><a href="#BlochSim.ExcitationMatrix"><code>BlochSim.ExcitationMatrix</code></a></li><li><a href="#BlochSim.FreePrecessionMatrix"><code>BlochSim.FreePrecessionMatrix</code></a></li><li><a href="#BlochSim.Gradient"><code>BlochSim.Gradient</code></a></li><li><a href="#BlochSim.GradientSpoiling"><code>BlochSim.GradientSpoiling</code></a></li><li><a href="#BlochSim.IdealSpoiling"><code>BlochSim.IdealSpoiling</code></a></li><li><a href="#BlochSim.IdealSpoilingMatrix"><code>BlochSim.IdealSpoilingMatrix</code></a></li><li><a href="#BlochSim.InstantaneousRF"><code>BlochSim.InstantaneousRF</code></a></li><li><a href="#BlochSim.MESEBlochSim"><code>BlochSim.MESEBlochSim</code></a></li><li><a href="#BlochSim.Magnetization"><code>BlochSim.Magnetization</code></a></li><li><a href="#BlochSim.MagnetizationMC"><code>BlochSim.MagnetizationMC</code></a></li><li><a href="#BlochSim.Position"><code>BlochSim.Position</code></a></li><li><a href="#BlochSim.RF"><code>BlochSim.RF</code></a></li><li><a href="#BlochSim.RFSpoiling"><code>BlochSim.RFSpoiling</code></a></li><li><a href="#BlochSim.RFandGradientSpoiling"><code>BlochSim.RFandGradientSpoiling</code></a></li><li><a href="#BlochSim.SPGRBlochSim"><code>BlochSim.SPGRBlochSim</code></a></li><li><a href="#BlochSim.Spin"><code>BlochSim.Spin</code></a></li><li><a href="#BlochSim.SpinMC"><code>BlochSim.SpinMC</code></a></li><li><a href="#BlochSim.bSSFPmode"><code>BlochSim.bSSFPmode</code></a></li><li><a href="#BlochSim.absolutesum-Tuple{BlochSim.BlochDynamicsMatrix}"><code>BlochSim.absolutesum</code></a></li><li><a href="#BlochSim.add!-Tuple{Magnetization, Magnetization}"><code>BlochSim.add!</code></a></li><li><a href="#BlochSim.add!-Tuple{AbstractVector, Magnetization, Magnetization}"><code>BlochSim.add!</code></a></li><li><a href="#BlochSim.applydynamics!-Tuple{AbstractSpin, Any, Any, Any}"><code>BlochSim.applydynamics!</code></a></li><li><a href="#BlochSim.bssfp-Tuple{Any, Number, Number, AbstractRF}"><code>BlochSim.bssfp</code></a></li><li><a href="#BlochSim.bssfp-Tuple{Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Vararg{Any}}"><code>BlochSim.bssfp</code></a></li><li><a href="#BlochSim.bssfp"><code>BlochSim.bssfp</code></a></li><li><a href="#BlochSim.bssfp-Tuple{Any, Number, Number, Number, AbstractRF}"><code>BlochSim.bssfp</code></a></li><li><a href="#BlochSim.bssfp"><code>BlochSim.bssfp</code></a></li><li><a href="#BlochSim.bssfp-Tuple{BlochSim.bSSFPmode{:Bloch}, Vararg{Any}}"><code>BlochSim.bssfp</code></a></li><li><a href="#BlochSim.combine!-NTuple{6, Any}"><code>BlochSim.combine!</code></a></li><li><a href="#BlochSim.div!-Tuple{Magnetization, Any}"><code>BlochSim.div!</code></a></li><li><a href="#BlochSim.duration-Tuple{InstantaneousRF}"><code>BlochSim.duration</code></a></li><li><a href="#BlochSim.excite"><code>BlochSim.excite</code></a></li><li><a href="#BlochSim.excite!-Tuple{ExcitationMatrix, AbstractSpin, InstantaneousRF}"><code>BlochSim.excite!</code></a></li><li><a href="#BlochSim.excite!-Tuple{AbstractSpin, Vararg{Any}}"><code>BlochSim.excite!</code></a></li><li><a href="#BlochSim.expm!-Union{Tuple{M}, Tuple{N}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}, BlochSim.MatrixExponentialWorkspace{T3, N}}} where {T1, T2, T3, N, M}"><code>BlochSim.expm!</code></a></li><li><a href="#BlochSim.freeprecess"><code>BlochSim.freeprecess</code></a></li><li><a href="#BlochSim.freeprecess-NTuple{5, Real}"><code>BlochSim.freeprecess</code></a></li><li><a href="#BlochSim.freeprecess!-Tuple{AbstractSpin, Vararg{Any}}"><code>BlochSim.freeprecess!</code></a></li><li><a href="#BlochSim.freeprecess!-NTuple{7, Any}"><code>BlochSim.freeprecess!</code></a></li><li><a href="#BlochSim.get_Δf_tuple-NTuple{4, Any}"><code>BlochSim.get_Δf_tuple</code></a></li><li><a href="#BlochSim.get_τ_tuple-Tuple{Any, Any}"><code>BlochSim.get_τ_tuple</code></a></li><li><a href="#BlochSim.gradient_frequency-Tuple{Gradient, Position}"><code>BlochSim.gradient_frequency</code></a></li><li><a href="#BlochSim.muladd!-Tuple{Magnetization, BlochMatrix, Magnetization}"><code>BlochSim.muladd!</code></a></li><li><a href="#BlochSim.rfspoiling_increment-Tuple{AbstractSpoiling}"><code>BlochSim.rfspoiling_increment</code></a></li><li><a href="#BlochSim.rotatetheta"><code>BlochSim.rotatetheta</code></a></li><li><a href="#BlochSim.rotatetheta!-Tuple{Any, Any, Any}"><code>BlochSim.rotatetheta!</code></a></li><li><a href="#BlochSim.signal-Tuple{Magnetization}"><code>BlochSim.signal</code></a></li><li><a href="#BlochSim.spoil"><code>BlochSim.spoil</code></a></li><li><a href="#BlochSim.spoil!-Union{Tuple{Spin{T}}, Tuple{T}} where T"><code>BlochSim.spoil!</code></a></li><li><a href="#BlochSim.spoil!"><code>BlochSim.spoil!</code></a></li><li><a href="#BlochSim.spoiler_gradient-Tuple{GradientSpoiling}"><code>BlochSim.spoiler_gradient</code></a></li><li><a href="#BlochSim.spoiler_gradient_duration-Tuple{AbstractSpoiling}"><code>BlochSim.spoiler_gradient_duration</code></a></li><li><a href="#BlochSim.subtract!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.UniformScaling, BlochMatrix}} where T"><code>BlochSim.subtract!</code></a></li><li><a href="#BlochSim.subtract!-Tuple{Magnetization, Magnetization}"><code>BlochSim.subtract!</code></a></li><li><a href="#BlochSim.subtractmul!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}"><code>BlochSim.subtractmul!</code></a></li><li><a href="#BlochSim.subtractmuladd!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}"><code>BlochSim.subtractmuladd!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{Magnetization, BlochMatrix, Magnetization}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{Magnetization, Any}"><code>LinearAlgebra.mul!</code></a></li></ul><h2 id="Methods-usage"><a class="docs-heading-anchor" href="#Methods-usage">Methods usage</a><a id="Methods-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-usage" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BlochSim.GAMBAR"><a class="docstring-binding" href="#BlochSim.GAMBAR"><code>BlochSim.GAMBAR</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">GAMBAR</code></pre><p>Gyromagnetic ratio for ¹H with units Hz/G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spin.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.GAMMA"><a class="docstring-binding" href="#BlochSim.GAMMA"><code>BlochSim.GAMMA</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">GAMMA</code></pre><p>Gyromagnetic ratio for ¹H with units rad/s/G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spin.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.AbstractRF"><a class="docstring-binding" href="#BlochSim.AbstractRF"><code>BlochSim.AbstractRF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractRF</code></pre><p>Abstract type for representing radiofrequency (RF) pulses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.AbstractSpin"><a class="docstring-binding" href="#BlochSim.AbstractSpin"><code>BlochSim.AbstractSpin</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSpin</code></pre><p>Abstract type for representing individual spins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spin.jl#L43-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.AbstractSpoiling"><a class="docstring-binding" href="#BlochSim.AbstractSpoiling"><code>BlochSim.AbstractSpoiling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSpoiling</code></pre><p>Abstract type for representing spoiling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.BlochDynamicsMatrix"><a class="docstring-binding" href="#BlochSim.BlochDynamicsMatrix"><code>BlochSim.BlochDynamicsMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BlochDynamicsMatrix(R1, R2, Δω)
BlochDynamicsMatrix{T}()
BlochDynamicsMatrix()</code></pre><p>Create a mutable <code>BlochDynamicsMatrix</code> object.</p><p><strong>Properties</strong></p><ul><li><code>R1::Real</code>: Spin-lattice relaxation rate</li><li><code>R2::Real</code>: Spin-spin relaxation rate</li><li><code>Δω::Real</code>: Off-resonance frequency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L101-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.BlochMatrix"><a class="docstring-binding" href="#BlochSim.BlochMatrix"><code>BlochSim.BlochMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BlochMatrix(a11, a21, a31, a12, a22, a32, a13, a23, a33)
BlochMatrix{T}()
BlochMatrix()</code></pre><p>Create a mutable <code>BlochMatrix</code> object representing a fixed-size 3×3 matrix.</p><p><strong>Properties</strong></p><ul><li><code>aij::Real</code>: Matrix entry (i,j) ∈ {1, 2, 3}²</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.BlochMcConnellDynamicsMatrix"><a class="docstring-binding" href="#BlochSim.BlochMcConnellDynamicsMatrix"><code>BlochSim.BlochMcConnellDynamicsMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BlochMcConnellDynamicsMatrix(A, E)
BlochMcConnellDynamicsMatrix{T}(N)
BlochMcConnellDynamicsMatrix(N)</code></pre><p>Create a <code>BlochMcConnellDynamicsMatrix</code> object with <code>N</code> compartments.</p><p><strong>Properties</strong></p><ul><li><code>A::NTuple{N,BlochDynamicsMatrix{&lt;:Real}}</code>: List of <code>BlochDynamicsMatrix</code>es that make up the main block diagonal of the <code>BlochMcConnellDynamicsMatrix</code></li><li><code>E::NTuple{M,ExchangeDynamicsMatrix{&lt;:Real}}</code>: List of <code>ExchangeDynamicsMatrix</code>es that describe exchange between the different compartments; these matrices make up the remaining <code>M = N^2 - N</code> blocks of the <code>BlochMcConnellDynamicsMatrix</code>, sorted by column-major ordering</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L286-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.BlochMcConnellMatrix"><a class="docstring-binding" href="#BlochSim.BlochMcConnellMatrix"><code>BlochSim.BlochMcConnellMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BlochMcConnellMatrix(A)
BlochMcConnellMatrix{T}(N)
BlochMcConnellMatrix(N)</code></pre><p>Create a <code>BlochMcConnellMatrix</code> object with <code>N</code> compartments and representing a fixed-size 3N×3N matrix.</p><p><strong>Properties</strong></p><ul><li><code>A::NTuple{N,NTuple{N,BlochMatrix{&lt;:Real}}}</code>: List of 3×3 matrices that comprise the blocks of the <code>BlochMcConnellMatrix</code>; <code>A[i][j]</code> is the (i,j)th block</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BlochMcConnellMatrix(3)
BlochMcConnellMatrix{Float64,3}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

julia&gt; fill!(B, 0.5)

julia&gt; B
BlochMcConnellMatrix{Float64,3}:
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5
 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L382-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.ExchangeDynamicsMatrix"><a class="docstring-binding" href="#BlochSim.ExchangeDynamicsMatrix"><code>BlochSim.ExchangeDynamicsMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExchangeDynamicsMatrix(r)
ExchangeDynamicsMatrix{T}()
ExchangeDynamicsMatrix()</code></pre><p>Create a mutable <code>ExchangeDynamicsMatrix</code> object.</p><p><strong>Properties</strong></p><ul><li><code>r::Real</code>: Exchange rate from one compartment to another</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L247-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.ExcitationMatrix"><a class="docstring-binding" href="#BlochSim.ExcitationMatrix"><code>BlochSim.ExcitationMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExcitationMatrix(A)
ExcitationMatrix{T}()
ExcitationMatrix()</code></pre><p>Create an <code>ExcitationMatrix</code> object. Multiplying by a <code>MagnetizationMC</code> object has the effect of multiplying each component of the multi-compartment magnetization by the <code>ExcitationMatrix</code>.</p><p><strong>Properties</strong></p><ul><li><code>A::BlochMatrix{&lt;:Real}</code>: Matrix used to describe the excitation</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; E = ExcitationMatrix(BlochMatrix(0, 1, 0, 1, 0, 0, 0, 0, 1))
ExcitationMatrix{Int64}:
 0  1  0
 1  0  0
 0  0  1

julia&gt; M = MagnetizationMC((1, 2, 3), (4, 5, 6))
2-compartment Magnetization vector with eltype Int64:
 Compartment 1:
  Mx = 1
  My = 2
  Mz = 3
 Compartment 2:
  Mx = 4
  My = 5
  Mz = 6

julia&gt; E * M
2-compartment Magnetization vector with eltype Int64:
 Compartment 1:
  Mx = 2
  My = 1
  Mz = 3
 Compartment 2:
  Mx = 5
  My = 4
  Mz = 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L555-L597">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.FreePrecessionMatrix"><a class="docstring-binding" href="#BlochSim.FreePrecessionMatrix"><code>BlochSim.FreePrecessionMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FreePrecessionMatrix(E1, E2, θ)
FreePrecessionMatrix{T}()
FreePrecessionMatrix()</code></pre><p>Create a mutable <code>FreePrecessionMatrix</code> object encoding the effects of relaxation and off-resonance precession.</p><p><strong>Properties</strong></p><ul><li><code>E1::Real</code>: T1 relaxation</li><li><code>E2::Real</code>: T2 relaxation</li><li><code>θ::Real</code>: Angle of off-resonance precession (rad)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; T1 = 1000; T2 = 100; Δω = π/600; t = 100;

julia&gt; F = FreePrecessionMatrix(exp(-t / T1), exp(-t / T2) * cos(Δω * t), exp(-t / T2) * sin(Δω * t))
FreePrecessionMatrix{Float64}:
 E1 = 0.9048374180359595
 E2 = 0.31859294158449203
 θ = 0.18393972058572114 rad

julia&gt; Matrix(F)
3×3 Matrix{Float64}:
  0.313219  0.058272  0.0
 -0.058272  0.313219  0.0
  0.0       0.0       0.904837</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L143-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.Gradient"><a class="docstring-binding" href="#BlochSim.Gradient"><code>BlochSim.Gradient</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Gradient(x, y, z)</code></pre><p>Create a <code>Gradient</code> object representing x, y, and z B0 gradients. Units are G/cm.</p><p><strong>Properties</strong></p><ul><li><code>x::Real</code>: x gradient</li><li><code>y::Real</code>: y gradient</li><li><code>z::Real</code>: z gradient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.GradientSpoiling"><a class="docstring-binding" href="#BlochSim.GradientSpoiling"><code>BlochSim.GradientSpoiling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GradientSpoiling(grad, Tg) &lt;: AbstractSpoiling
GradientSpoiling(gx, gy, gz, Tg)</code></pre><p>Represents gradient spoiling, e.g., applying a gradient <code>grad = Gradient(gx, gy, gz)</code> for time <code>Tg</code> (ms). <code>grad</code> can be a <code>Gradient</code> (or <code>gx</code>, <code>gy</code>, and <code>gz</code> can be scalars), representing a constant gradient, or <code>grad</code> can be a collection of <code>Gradient</code>s (or <code>gx</code>, <code>gy</code>, and <code>gz</code> can be collections of values), representing a gradient waveform with a constant time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L51-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.IdealSpoiling"><a class="docstring-binding" href="#BlochSim.IdealSpoiling"><code>BlochSim.IdealSpoiling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IdealSpoiling() &lt;: AbstractSpoiling</code></pre><p>Represents ideal spoiling, i.e., setting the transverse (x and y) components of a spin&#39;s magnetization to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L43-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.IdealSpoilingMatrix"><a class="docstring-binding" href="#BlochSim.IdealSpoilingMatrix"><code>BlochSim.IdealSpoilingMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">idealspoiling = IdealSpoilingMatrix()</code></pre><p>Matrix representing ideal spoiling. Multiplying by a <code>Magnetization</code> or <code>MagnetizationMC</code> has the effect of setting the x and y components to 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; idealspoiling * MagnetizationMC((1, 1, 1), (2, 2, 2))
2-compartment Magnetization vector with eltype Int64:
 Compartment 1:
  Mx = 0
  My = 0
  Mz = 1
 Compartment 2:
  Mx = 0
  My = 0
  Mz = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L616-L635">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.InstantaneousRF"><a class="docstring-binding" href="#BlochSim.InstantaneousRF"><code>BlochSim.InstantaneousRF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InstantaneousRF(α, θ = 0) &lt;: AbstractRF</code></pre><p>Represents an idealized instantaneous RF pulse with flip angle <code>α</code> and phase <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L8-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.MESEBlochSim"><a class="docstring-binding" href="#BlochSim.MESEBlochSim"><code>BlochSim.MESEBlochSim</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mese! = MESEBlochSim(TR, TE, nechoes, [rfex, rfref, rephaser, crusher, spoiling])
mese!(spin, [workspace])</code></pre><p>Simulate a multi-echo spin echo (MESE) scan on <code>spin</code>, overwriting the spin&#39;s magnetization vector. Returns a <code>Vector</code> with the magnetization vectors at each echo.</p><p><strong>Arguments</strong></p><ul><li><code>TR::Real</code>: Repetition time (ms)</li><li><code>TE::Real</code>: First echo time, and echo spacing (ms); the first echo time is measured from the middle of the excitation pulse</li><li><code>nechoes::Integer</code>: Number of echoes to readout</li><li><code>rfex::AbstractRF = InstantaneousRF(π/2)</code>: Excitation RF pulse</li><li><code>rfref::AbstractRF = InstantaneousRF(π, -π/2)</code>: Refocussing RF pulse</li><li><code>rephaser::Union{&lt;:GradientSpoiling,Nothing} = nothing</code>: Slice-select excitation rephasing gradient</li><li><code>crusher::Union{&lt;:GradientSpoiling,Nothing} = nothing</code>: Crusher gradient (placed on either side of each refocussing pulse)</li><li><code>spoiling::Union{IdealSpoiling,&lt;:GradientSpoiling,Nothing} = IdealSpoiling()</code>: Type of spoiling to apply</li></ul><p><code>workspace isa MESEBlochSimWorkspace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/mese.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.Magnetization"><a class="docstring-binding" href="#BlochSim.Magnetization"><code>BlochSim.Magnetization</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Magnetization(x, y, z)
Magnetization{T}()
Magnetization()</code></pre><p>Create a mutable <code>Magnetization</code> object representing a 3D magnetization vector.</p><p><strong>Properties</strong></p><ul><li><code>x::Real</code>: x component of magnetization vector</li><li><code>y::Real</code>: y component of magnetization vector</li><li><code>z::Real</code>: z component of magnetization vector</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = Magnetization()
Magnetization vector with eltype Float64:
 Mx = 0.0
 My = 0.0
 Mz = 0.0

julia&gt; M.x = 1; M.y = 2; M.z = 3; M
Magnetization vector with eltype Float64:
 Mx = 1.0
 My = 2.0
 Mz = 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/magnetization.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.MagnetizationMC"><a class="docstring-binding" href="#BlochSim.MagnetizationMC"><code>BlochSim.MagnetizationMC</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MagnetizationMC((x1, y1, z1), ...)
MagnetizationMC{T}(N)
MagnetizationMC(N)</code></pre><p>Create a <code>MagnetizationMC</code> object representing <code>N</code> 3D magnetization vectors in the same physical location.</p><p>One can access the ith component magnetization vector by indexing the <code>MagnetizationMC</code> object. Furthermore, iterating the <code>MagnetizationMC</code> object iterates through each of the component magnetization vectors.</p><p><strong>Properties</strong></p><ul><li><code>M::NTuple{N,Magnetization{&lt;:Real}}</code>: List of component magnetization vectors</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = MagnetizationMC((1, 2, 3), (4, 5, 6))
2-compartment Magnetization vector with eltype Int64:
 Compartment 1:
  Mx = 1
  My = 2
  Mz = 3
 Compartment 2:
  Mx = 4
  My = 5
  Mz = 6

julia&gt; M[2]
Magnetization vector with eltype Int64:
 Mx = 4
 My = 5
 Mz = 6

julia&gt; foreach(m -&gt; (m.x = 0; m.y = 1; m.z = 2), M)

julia&gt; M
2-compartment Magnetization vector with eltype Int64:
 Compartment 1:
  Mx = 0
  My = 1
  Mz = 2
 Compartment 2:
  Mx = 0
  My = 1
  Mz = 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/magnetization.jl#L106-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.Position"><a class="docstring-binding" href="#BlochSim.Position"><code>BlochSim.Position</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Position(x, y, z)</code></pre><p>Create a mutable <code>Position</code> object representing a 3D location. Units are cm.</p><p><strong>Properties</strong></p><ul><li><code>x::Real</code>: x position</li><li><code>y::Real</code>: y position</li><li><code>z::Real</code>: z position</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spin.jl#L15-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.RF"><a class="docstring-binding" href="#BlochSim.RF"><code>BlochSim.RF</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RF(waveform, Δt, [Δθ], [grad]) &lt;: AbstractRF</code></pre><p>Represent an RF pulse with the given (possibly complex-valued) <code>waveform</code> (G) and time step <code>Δt</code> (ms).</p><p><strong>Options</strong></p><ul><li><code>Δθ</code> additional phase added to the waveform (defaults to <code>0</code> radians)</li><li><code>grad</code> B0 gradient that is turned on during the RF pulse (defaults to <code>Gradient(0, 0, 0)</code>, i.e., turned off).</li></ul><p><strong>Properties</strong></p><ul><li><code>α::Vector{&lt;:Real}</code>: Instantaneous flip angles (rad) at each time point; computed from the magnitude of <code>waveform</code></li><li><code>θ::Vector{&lt;:Real}</code>: Instantaneous phase (rad) at each time point; computed from the phase of <code>waveform</code></li><li><code>Δt::Real</code>: Time step (ms)</li><li><code>Δθ_initial::Real</code>: Phase added to <code>θ</code> before any phase-cycling increment has been applied</li><li><code>Δθ::Ref{&lt;:Real}</code>: Phase to be added to <code>θ</code>; can be updated to simulate phase-cycling/RF spoiling</li><li><code>grad</code>: Gradient applied during the RF pulse<ul><li><code>::Gradient</code>: Constant gradient</li><li><code>::Vector{&lt;:Gradient}</code>: Time-varying gradient</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L25-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.RFSpoiling"><a class="docstring-binding" href="#BlochSim.RFSpoiling"><code>BlochSim.RFSpoiling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RFSpoiling(Δθ = 117°) &lt;: AbstractSpoiling</code></pre><p>Represents RF spoiling, i.e., quadratically incrementing the phase of the RF pulses from TR to TR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L93-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.RFandGradientSpoiling"><a class="docstring-binding" href="#BlochSim.RFandGradientSpoiling"><code>BlochSim.RFandGradientSpoiling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RFandGradientSpoiling(grad_spoiling, rf_spoiling) &lt;: AbstractSpoiling</code></pre><p>Represents both RF and gradient spoiling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.SPGRBlochSim"><a class="docstring-binding" href="#BlochSim.SPGRBlochSim"><code>BlochSim.SPGRBlochSim</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">spgr! = SPGRBlochSim(TR, TE, rf, [spoiling], [nTR], [save_transients])
spgr!(spin, [workspace])</code></pre><p>Simulate a spoiled gradient-recalled echo (SPGR) scan on <code>spin</code>, overwriting the spin&#39;s magnetization vector. The resultant magnetization is stored in <code>spin.M</code>. If <code>nTR &gt; 0</code> and <code>save_transients === true</code>, then <code>spgr!(...)</code> returns a <code>Vector</code> with the magnetization vectors at the echo time for each of the <code>nTR</code> simulated TRs.</p><p><strong>Arguments</strong></p><ul><li><code>TR::Real</code>: Repetition time (ms)</li><li><code>TE::Real</code>: Echo time (ms)</li><li><code>rf</code>:<ul><li><code>::Real</code>: Excitation flip angle (rad) (assumes an instantaneous RF pulse)</li><li><code>::AbstractRF</code>: Excitation RF pulse</li></ul></li><li><code>spoiling::AbstractSpoiling = IdealSpoiling()</code>: Type of spoiling to apply</li><li><code>nTR::Val = Val(0)</code>: Number of TRs to simulate; <code>Val(0)</code> indicates to simulate a steady-state scan</li><li><code>save_transients::Val = Val(false)</code>: Whether or not to return the magnetization vectors at the TE for each of the <code>nTR</code> simulated TRs; does nothing if <code>nTR == 0</code></li></ul><p><code>workspace isa SPGRBlochSimWorkspace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spgr.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.Spin"><a class="docstring-binding" href="#BlochSim.Spin"><code>BlochSim.Spin</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Spin([M], M0, T1, T2, Δf, [pos]) &lt;: AbstractSpin</code></pre><p>Create an object that represents a single spin.</p><p><strong>Properties</strong></p><ul><li><code>M::Magnetization = Magnetization(0, 0, M0)</code>: Magnetization vector</li><li><code>M0::Real</code>: Equilibrium magnetization</li><li><code>T1::Real</code>: Spin-lattice recovery time constant (ms)</li><li><code>T2::Real</code>: Spin-spin recovery time constant (ms)</li><li><code>Δf::Real</code>: Off-resonance frequency (Hz)</li><li><code>pos::Position = Position(0, 0, 0)</code>: Spatial location (cm)</li><li><code>N::Int = 1</code>: Number of compartments</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Spin(1, 1000, 100, 0, Position(1, 2, 3))
Spin{Float64}:
 M = Magnetization(0.0, 0.0, 1.0)
 M0 = 1.0
 T1 = 1000.0 ms
 T2 = 100.0 ms
 Δf = 0.0 Hz
 pos = Position(1.0, 2.0, 3.0) cm

julia&gt; Spin(Magnetization(1, 2, 3), 1, 1000, 100, 0)
Spin{Float64}:
 M = Magnetization(1.0, 2.0, 3.0)
 M0 = 1.0
 T1 = 1000.0 ms
 T2 = 100.0 ms
 Δf = 0.0 Hz
 pos = Position(0.0, 0.0, 0.0) cm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spin.jl#L50-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.SpinMC"><a class="docstring-binding" href="#BlochSim.SpinMC"><code>BlochSim.SpinMC</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpinMC([M], M0, frac, T1, T2, Δf, τ, [pos]) &lt;: AbstractSpin</code></pre><p>Create an object that represents a single spin with multiple compartments.</p><p><strong>Properties</strong></p><ul><li><code>M::MagnetizationMC = Meq</code>: Magnetization vector</li><li><code>Meq::MagnetizationMC = MagnetizationMC((0, 0, frac[1] * M0), ...)</code>: Equilibrium magnetization vector</li><li><code>M0::Real</code>: Equilibrium magnetization</li><li><code>frac::Tuple{&lt;:Real}</code>: Water fraction of each compartment</li><li><code>T1::Tuple{&lt;:Real}</code>: Spin-lattice recovery time constants (ms)</li><li><code>T2::Tuple{&lt;:Real}</code>: Spin-spin recovery time constants (ms)</li><li><code>Δf::Tuple{&lt;:Real}</code>: Off-resonance frequencies (Hz)</li><li><code>r::Tuple{Tuple{&lt;:Real}}</code>: Exchange rates (1/ms); <code>r[i][j]</code> is the exchange rate from compartment <code>i</code> to compartment <code>j</code></li><li><code>pos::Position = Position(0, 0, 0)</code>: Spatial location (cm)</li><li><code>N::Int = length(frac)</code>: Number of compartments</li></ul><p><strong>Note</strong></p><p>The <code>SpinMC</code> constructor takes <code>τ</code> (inverse exchange rate, or residence time) as input, <em>not</em> <code>r</code>. Furthermore, <code>τ</code> is given as a <code>Tuple</code> with <code>N^2 - N</code> elements, arranged like (τ12, τ13, ..., τ1N, τ21, τ23, ..., τ2N, ...).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SpinMC(1, (0.2, 0.8), (400, 1000), (20, 100), (15, 0), (100, 25))
SpinMC{Float64,2}:
 M = MagnetizationMC((0.0, 0.0, 0.2), (0.0, 0.0, 0.8))
 M0 = 1.0
 frac = (0.2, 0.8)
 T1 = (400.0, 1000.0) ms
 T2 = (20.0, 100.0) ms
 Δf = (15.0, 0.0) Hz
 r = ((0.0, 0.01), (0.04, 0.0)) 1/ms
 pos = Position(0.0, 0.0, 0.0) cm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spin.jl#L136-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bSSFPmode"><a class="docstring-binding" href="#BlochSim.bSSFPmode"><code>BlochSim.bSSFPmode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">bSSFPmode</code></pre><p>A type used to control how bSSFP signal is calculated.</p><ul><li><code>bSSFPbloch</code> use <code>BlochSim</code> matrix computations (default)</li><li><code>bSSFPellipse</code> use ellipse model for 1-pool</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L16-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.absolutesum-Tuple{BlochSim.BlochDynamicsMatrix}"><a class="docstring-binding" href="#BlochSim.absolutesum-Tuple{BlochSim.BlochDynamicsMatrix}"><code>BlochSim.absolutesum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">absolutesum(A)</code></pre><p>Compute the sum of the absolute values of the elements of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L1618-L1622">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.add!-Tuple{AbstractVector, Magnetization, Magnetization}"><a class="docstring-binding" href="#BlochSim.add!-Tuple{AbstractVector, Magnetization, Magnetization}"><code>BlochSim.add!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add!(C, A, B)</code></pre><p>Compute <code>A + B</code>, storing the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L835-L839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.add!-Tuple{Magnetization, Magnetization}"><a class="docstring-binding" href="#BlochSim.add!-Tuple{Magnetization, Magnetization}"><code>BlochSim.add!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add!(A, B)</code></pre><p>Compute <code>A + B</code>, storing the result in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L813-L817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.applydynamics!-Tuple{AbstractSpin, Any, Any, Any}"><a class="docstring-binding" href="#BlochSim.applydynamics!-Tuple{AbstractSpin, Any, Any, Any}"><code>BlochSim.applydynamics!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">applydynamics!(spin, BtoM, A, [B])</code></pre><p>Apply dynamics to the given spin, overwriting the spin&#39;s magnetization vector. <code>BtoM</code> is used to store intermediate results (and is thus overwritten).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Spin(1, 1000, 100, 3.75); s.M
Magnetization vector with eltype Float64:
 Mx = 0.0
 My = 0.0
 Mz = 1.0

julia&gt; BtoM = Magnetization();

julia&gt; (A,) = excite(s, InstantaneousRF(π/2)); applydynamics!(s, BtoM, A); s.M
Magnetization vector with eltype Float64:
 Mx = 1.0
 My = 0.0
 Mz = 6.123233995736766e-17

julia&gt; (A, B) = freeprecess(s, 100); applydynamics!(s, BtoM, A, B); s.M
Magnetization vector with eltype Float64:
 Mx = -0.2601300475114444
 My = -0.2601300475114445
 Mz = 0.09516258196404054</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/freeprecess.jl#L476-L504">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bssfp"><a class="docstring-binding" href="#BlochSim.bssfp"><code>BlochSim.bssfp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bssfp(spin, spin_no_rf_phase_fact, TR_ms, TE_ms, α_rad, θ_rf_rad=0)
bssfp(spin, spin_no_rf_phase_fact, TR_ms, TE_ms, rf)</code></pre><p>Return steady-state magnetization signal value at the echo time for a phase-cycled bSSFP sequence using BlochSim.</p><p>Ref: Murthy, N., Nielsen, J. F., Whitaker, S. T., Haskell, M. W., Swanson, S. D., Seiberlich, N., &amp; Fessler, J. A. (2022). Quantifying myelin water exchange using optimized bSSFP sequences. In Proc. Intl. Soc. Mag. Res. Med (p. 2068). [2]</p><p><strong>In (tissue)</strong></p><ul><li>&#39;spin&#39; multi-compartment spin object with RF phase cycling factor</li><li>&#39;spin<em>no</em>rf<em>phase</em>fact&#39; multi-compartment spin object without RF phase cycling factor</li></ul><p><strong>In (scan)</strong></p><ul><li><code>TR_ms</code> repetition time (ms)</li><li><code>TE_ms</code> echo time (ms)</li><li><code>α_rad</code> flip angle of RF pulse (radians)</li><li><code>θ_rf_rad</code> phase angle of RF pulse (radians) [default 0]</li></ul><p>Or instead provide</p><ul><li><code>rf::AbstractRF</code></li></ul><p><strong>Out</strong></p><ul><li><code>signal</code> steady-state magnetization (as a complex number)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L238-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bssfp"><a class="docstring-binding" href="#BlochSim.bssfp"><code>BlochSim.bssfp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bssfp(bSSFPellipse, Mz0, T1_ms, T2_ms, Δf_Hz,
   TR_ms, TE_ms, Δϕ_rad, α_rad, θ_rf_rad=0)</code></pre><p>Elliptical signal model for bSSFP. This is the analytical solution to the 1-pool bSSFP signal.</p><p>Xiang et al. MRM 2014; https://doi.org/10.1002/mrm.25098</p><p>Keskin et al. IEEE T-MI 2022; https://doi.org/10.1109/TMI.2021.3102852</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L28-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bssfp-Tuple{Any, Number, Number, AbstractRF}"><a class="docstring-binding" href="#BlochSim.bssfp-Tuple{Any, Number, Number, AbstractRF}"><code>BlochSim.bssfp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function bssfp(spin, TR_ms, TE_ms, rf::AbstractRF)</code></pre><p>Classic version with no phase cycling increment, for InstantaneousRF only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L120-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bssfp-Tuple{Any, Number, Number, Number, AbstractRF}"><a class="docstring-binding" href="#BlochSim.bssfp-Tuple{Any, Number, Number, Number, AbstractRF}"><code>BlochSim.bssfp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function bssfp(spin, TR_ms, TE_ms, Δϕ_rad, rf::AbstractRF)</code></pre><p>Signal accounting for  phase cycling increment <code>Δϕ_rad</code>, allowing for finite duration <code>rf</code> pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L151-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bssfp-Tuple{BlochSim.bSSFPmode{:Bloch}, Vararg{Any}}"><a class="docstring-binding" href="#BlochSim.bssfp-Tuple{BlochSim.bSSFPmode{:Bloch}, Vararg{Any}}"><code>BlochSim.bssfp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bssfp(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, α_rad, θ_rf_rad=0)
bssfp(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, rf, [pos])
bssfp(spin, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, rf)</code></pre><p>Return steady-state magnetization signal value at the echo time for a bSSFP sequence using <code>BlochSim</code>.</p><p>This generalizes <a href="https://doi.org/10.1002/mrm.1170">Hargreaves et al., MRM 2001</a> by accounting for finite RF duration.</p><p><strong>In (tissue parameters):</strong></p><ul><li><code>Mz0</code> initial condition for magnetization in the z-direction (constant)</li><li><code>T1_ms</code> MRI tissue parameter for T1 relaxation (ms)</li><li><code>T2_ms</code> MRI tissue parameter for T2 relaxation (ms)</li><li><code>Δf_Hz</code> off-resonance value (Hz)</li></ul><p><strong>In (scan parameters):</strong></p><ul><li><code>TR_ms</code> repetition time (ms)</li><li><code>TE_ms</code> echo time (ms), measured from <em>middle</em> of RF pulse</li><li><code>Δϕ_rad</code> RF phase cycling increment (radians)</li><li><code>α_rad</code> flip angle of RF pulse (radians)</li><li><code>θ_rf_rad</code> phase of RF pulse (radians)</li></ul><p>Or, instead of <code>α_rad</code> and <code>θ_rf_rad</code>, provide:</p><ul><li><code>rf::AbstractRF</code>, e.g., <code>InstantaneousRF(α_rad, θ_rf_rad)</code></li></ul><p><strong>Option:</strong></p><ul><li><code>pos::Position = Position(0.0, 0.0, 0.0)</code> option if <code>rf</code> specified</li></ul><p><strong>Out</strong></p><ul><li><code>signal</code> steady-state transverse magnetization (as a complex number)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L61-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.bssfp-Tuple{Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Vararg{Any}}"><a class="docstring-binding" href="#BlochSim.bssfp-Tuple{Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Vararg{Any}}"><code>BlochSim.bssfp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bssfp(...)</code></pre><p>Version with scalar arguments (convenient for autodiff)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L329-L332">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.combine!-NTuple{6, Any}"><a class="docstring-binding" href="#BlochSim.combine!-NTuple{6, Any}"><code>BlochSim.combine!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">combine!(A, B, A1, B1, A2, B2)
combine!(A, A1, A2)</code></pre><p>Combine the matrices and vectors that describe the dynamics of a spin into one matrix and one vector, overwriting <code>A</code> and <code>B</code>. The dynamics described by <code>A1</code> and <code>B1</code> apply first, then those described by <code>A2</code> and <code>B2</code>. In other words, <code>A = A2 * A1</code> and <code>B = A2 * B1 + B2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Spin(1, 1000, 100, 3.75);

julia&gt; A = BlochMatrix(); B = Magnetization();

julia&gt; (A1, B1) = excite(s, InstantaneousRF(π/2));

julia&gt; (A2, B2) = freeprecess(s, 100);

julia&gt; combine!(A, B, A1, B1, A2, B2); A * s.M + B
Magnetization vector with eltype Float64:
 Mx = -0.2601300475114444
 My = -0.2601300475114445
 Mz = 0.09516258196404054</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/freeprecess.jl#L412-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.div!-Tuple{Magnetization, Any}"><a class="docstring-binding" href="#BlochSim.div!-Tuple{Magnetization, Any}"><code>BlochSim.div!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">div!(A, a)</code></pre><p>Compute <code>A / a</code>, storing the result in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L1345-L1349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.duration-Tuple{InstantaneousRF}"><a class="docstring-binding" href="#BlochSim.duration-Tuple{InstantaneousRF}"><code>BlochSim.duration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">duration(rf)</code></pre><p>Return the duration (ms) of the RF pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L97-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.excite"><a class="docstring-binding" href="#BlochSim.excite"><code>BlochSim.excite</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">excite(spin, rf::InstantaneousRF, [nothing])
excite(spin, rf::RF, [workspace])</code></pre><p>Simulate excitation for the given spin. Returns <code>(A, B)</code> such that <code>A * M + B</code> applies excitation to the magnetization <code>M</code>. If <code>isnothing(B)</code> (as is the case for <code>InstantaneousRF</code>s), then <code>A * M</code> applies excitation to <code>M</code>.</p><p>For <code>RF</code> objects, <code>workspace isa ExcitationWorkspace</code>. For <code>SpinMC</code> objects, use <code>workspace = ExcitationWorkspace(spin, nothing)</code> to use an approximate matrix exponential to solve the Bloch-McConnell equation.</p><p>For an in-place version, see <a href="#BlochSim.excite!-Tuple{AbstractSpin, Vararg{Any}}"><code>excite!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Spin(1, 1000, 100, 3.75); s.M
Magnetization vector with eltype Float64:
 Mx = 0.0
 My = 0.0
 Mz = 1.0

julia&gt; (A,) = excite(s, InstantaneousRF(π/2, π/4)); A * s.M
Magnetization vector with eltype Float64:
 Mx = 0.7071067811865476
 My = -0.7071067811865475
 Mz = 6.123233995736766e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L224-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.excite!-Tuple{AbstractSpin, Vararg{Any}}"><a class="docstring-binding" href="#BlochSim.excite!-Tuple{AbstractSpin, Vararg{Any}}"><code>BlochSim.excite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excite!(spin, ...)</code></pre><p>Apply excitation to the given spin, overwriting the spin&#39;s magnetization vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L330-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.excite!-Tuple{ExcitationMatrix, AbstractSpin, InstantaneousRF}"><a class="docstring-binding" href="#BlochSim.excite!-Tuple{ExcitationMatrix, AbstractSpin, InstantaneousRF}"><code>BlochSim.excite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">excite!(A, [nothing], spin, rf::InstantaneousRF, [nothing])
excite!(A, B, spin, rf::RF, [workspace])</code></pre><p>Simulate excitation, overwriting <code>A</code> and <code>B</code> (in-place version of <a href="#BlochSim.excite"><code>excite</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L261-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.expm!-Union{Tuple{M}, Tuple{N}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}, BlochSim.MatrixExponentialWorkspace{T3, N}}} where {T1, T2, T3, N, M}"><a class="docstring-binding" href="#BlochSim.expm!-Union{Tuple{M}, Tuple{N}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}, BlochSim.MatrixExponentialWorkspace{T3, N}}} where {T1, T2, T3, N, M}"><code>BlochSim.expm!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expm!(expA, A, [workspace])</code></pre><p>Compute the matrix exponential of <code>A</code>, storing it in <code>expA</code>.</p><p><code>workspace isa MatrixExponentialWorkspace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/expm.jl#L81-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.freeprecess"><a class="docstring-binding" href="#BlochSim.freeprecess"><code>BlochSim.freeprecess</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">freeprecess(spin, t, [nothing])
freeprecess(spinmc, t, [workspace])
freeprecess(spin, t, grad, [nothing])
freeprecess(spinmc, t, grad, [workspace])</code></pre><p>Simulate free-precession for the given spin for time <code>t</code> ms, optionally in the presence of a B0 gradient. Returns <code>(A, B)</code> such that <code>A * M + B</code> applies free-precession to the magnetization <code>M</code>.</p><p>For <code>SpinMC</code> objects, <code>workspace isa BlochMcConnellWorkspace</code>. Pass in <code>nothing</code> instead to use an approximate matrix exponential to solve the Bloch-McConnell equation.</p><p>For an in-place version, see <a href="#BlochSim.freeprecess!-NTuple{7, Any}"><code>freeprecess!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Spin(Magnetization(1, 0, 0), 1, 1000, 100, 3.75)
Spin{Float64}:
 M = Magnetization(1.0, 0.0, 0.0)
 M0 = 1.0
 T1 = 1000.0 ms
 T2 = 100.0 ms
 Δf = 3.75 Hz
 pos = Position(0.0, 0.0, 0.0) cm

julia&gt; (A, B) = freeprecess(s, 100); A * s.M + B
Magnetization vector with eltype Float64:
 Mx = -0.2601300475114444
 My = -0.2601300475114445
 Mz = 0.09516258196404048

julia&gt; s = Spin(Magnetization(1, 0, 0), 1, 1000, 100, 0, Position(0, 0, 3.75))
Spin{Float64}:
 M = Magnetization(1.0, 0.0, 0.0)
 M0 = 1.0
 T1 = 1000.0 ms
 T2 = 100.0 ms
 Δf = 0.0 Hz
 pos = Position(0.0, 0.0, 3.75) cm

julia&gt; (A, B) = freeprecess(s, 100, Gradient(0, 0, 1/GAMBAR)); A * s.M + B
Magnetization vector with eltype Float64:
 Mx = -0.2601300475114444
 My = -0.2601300475114445
 Mz = 0.09516258196404048</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/freeprecess.jl#L70-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.freeprecess!-NTuple{7, Any}"><a class="docstring-binding" href="#BlochSim.freeprecess!-NTuple{7, Any}"><code>BlochSim.freeprecess!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">freeprecess!(A, B, t, M0, T1, T2, Δf)
freeprecess!(A, B, spin, t, [nothing])
freeprecess!(A, B, spinmc, t, [workspace])
freeprecess!(A, B, spin, t, grad, [nothing])
freeprecess!(A, B, spinmc, t, grad, [workspace])</code></pre><p>Simulate free-precession, overwriting <code>A</code> and <code>B</code> (in-place version of <a href="#BlochSim.freeprecess"><code>freeprecess</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/freeprecess.jl#L46-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.freeprecess!-Tuple{AbstractSpin, Vararg{Any}}"><a class="docstring-binding" href="#BlochSim.freeprecess!-Tuple{AbstractSpin, Vararg{Any}}"><code>BlochSim.freeprecess!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">freeprecess!(spin, ...)</code></pre><p>Apply free-precession to the given spin, overwriting the spin&#39;s magnetization vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/freeprecess.jl#L398-L403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.freeprecess-NTuple{5, Real}"><a class="docstring-binding" href="#BlochSim.freeprecess-NTuple{5, Real}"><code>BlochSim.freeprecess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">freeprecess(t, M0, T1, T2, Δf)</code></pre><p>Simulate free-precession, i.e., relaxation and off-resonance precession. Returns <code>(A, B)</code> such that <code>A * M + B</code> applies free-precession to the magnetization <code>M</code>.</p><p>For an in-place version, see <a href="#BlochSim.freeprecess!-NTuple{7, Any}"><code>freeprecess!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>t::Real</code>: Duration of free-precession (ms)</li><li><code>M0::Real</code>: Equilibrium magnetization</li><li><code>T1::Real</code>: Spin-lattice recovery time constant (ms)</li><li><code>T2::Real</code>: Spin-spin recovery time constant (ms)</li><li><code>Δf::Real</code>: Off-resonance frequency (Hz)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (A, B) = freeprecess(100, 1, 1000, 100, 3.75); A * Magnetization(1, 0, 0) + B
Magnetization vector with eltype Float64:
 Mx = -0.2601300475114444
 My = -0.2601300475114445
 Mz = 0.09516258196404048</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/freeprecess.jl#L13-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.get_Δf_tuple-NTuple{4, Any}"><a class="docstring-binding" href="#BlochSim.get_Δf_tuple-NTuple{4, Any}"><code>BlochSim.get_Δf_tuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_Δf_tuple(Δϕ_rad, Δf0_Hz, Δf_myelin_Hz, TR_ms)</code></pre><p>Account for phase cycling increments as an effective frequency shift</p><p><strong>In:</strong></p><ul><li><code>Δϕ_rad</code> RF phase cycling value (radians)</li><li><code>Δf0_Hz</code> off-resonance value (Hz)</li><li><code>Δf_myelin_Hz</code> # additional off-resonance value only experienced by myelin water (Hz)</li><li><code>TR_ms</code> repetition time (ms)</li></ul><p><strong>Out:</strong></p><ul><li><code>Δf_tuple_Hz</code> tuple with off-resonance values for fast and slow compartments</li></ul><p><a href="https://doi.org/10.1063/1.323136">Hinshaw, J. Appl. Phys. 1976</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L205-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.get_τ_tuple-Tuple{Any, Any}"><a class="docstring-binding" href="#BlochSim.get_τ_tuple-Tuple{Any, Any}"><code>BlochSim.get_τ_tuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_τ_tuple(τ_fs_ms, f_f)</code></pre><p><strong>In:</strong></p><ul><li><code>τ_fs_ms</code> residence time for exchange from myelin to non-myelin water (ms)</li><li><code>f_f</code> fast fraction (myelin fraction)</li></ul><p><strong>Out:</strong></p><ul><li><code>τ_tuple_ms</code> tuple with fast-to-slow and slow-to-fast residence times</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/bssfp.jl#L191-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.gradient_frequency-Tuple{Gradient, Position}"><a class="docstring-binding" href="#BlochSim.gradient_frequency-Tuple{Gradient, Position}"><code>BlochSim.gradient_frequency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient_frequency(grad, pos)</code></pre><p>Compute the off-resonance frequency in Hz induced by the given B0 gradient <code>grad</code> at position <code>pos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L24-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.muladd!-Tuple{Magnetization, BlochMatrix, Magnetization}"><a class="docstring-binding" href="#BlochSim.muladd!-Tuple{Magnetization, BlochMatrix, Magnetization}"><code>BlochSim.muladd!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">muladd!(C, A, B)</code></pre><p>Compute <code>A * B + C</code>, storing the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L1353-L1357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.rfspoiling_increment-Tuple{AbstractSpoiling}"><a class="docstring-binding" href="#BlochSim.rfspoiling_increment-Tuple{AbstractSpoiling}"><code>BlochSim.rfspoiling_increment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rfspoiling_increment(spoiling)</code></pre><p>Return the quadratic phase increment used for RF spoiling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L151-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.rotatetheta"><a class="docstring-binding" href="#BlochSim.rotatetheta"><code>BlochSim.rotatetheta</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rotatetheta(α::Real = π/2, θ::Real = 0)</code></pre><p>Return a <code>3 × 3</code> <code>BlochMatrix</code> for (left-handed) flip angle <code>α</code> about an axis in the x-y plane that makes (left-handed) angle <code>θ</code> with the negative y-axis.</p><p>For an in-place version, see <a href="#BlochSim.rotatetheta!-Tuple{Any, Any, Any}"><code>rotatetheta!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BlochSim.rotatetheta() * Magnetization(0, 0, 1) # Rotate towards positive x-axis
Magnetization vector with eltype Float64:
 Mx = 1.0
 My = 0.0
 Mz = 6.123233995736766e-17

julia&gt; BlochSim.rotatetheta(π/2, π/2) * Magnetization(0, 0, 1) # Rotate towards negative y-axis
Magnetization vector with eltype Float64:
 Mx = 6.123233995736766e-17
 My = -1.0
 Mz = 6.123233995736766e-17</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L191-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.rotatetheta!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#BlochSim.rotatetheta!-Tuple{Any, Any, Any}"><code>BlochSim.rotatetheta!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rotatetheta!(A, α, θ)</code></pre><p>Simulate left-handed rotation by angle <code>α</code> about an axis in the x-y plane that makes left-handed angle <code>θ</code> with the negative y-axis, overwriting <code>A</code>.</p><p>This function is an in-place version of <a href="#BlochSim.rotatetheta"><code>rotatetheta</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/excite.jl#L150-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.signal-Tuple{Magnetization}"><a class="docstring-binding" href="#BlochSim.signal-Tuple{Magnetization}"><code>BlochSim.signal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">signal(spin)
signal(M)</code></pre><p>Return the signal detected from the given spin or magnetization vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; signal(Spin(Magnetization(1, 2, 3), 1, 1000, 100, 0))
1.0 + 2.0im

julia&gt; signal(MagnetizationMC((1, 2, 3), (1, 1, 1)))
2 + 3im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/magnetization.jl#L89-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.spoil"><a class="docstring-binding" href="#BlochSim.spoil"><code>BlochSim.spoil</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spoil(spin, spoiling, [nothing])
spoil(spinmc, spoiling, [workspace])</code></pre><p>Simulate gradient or ideal spoiling for the given spin. Returns <code>(A, B)</code>, such that <code>A * M + B</code> applies spoiling to the magnetization <code>M</code>. If <code>B</code> is <code>nothing</code> (as is the case for <code>IdealSpoiling</code>), then <code>A * M</code> applies spoiling, and if both <code>A</code> and <code>B</code> are <code>nothing</code> (as is the case for <code>RFSpoiling</code>) then there is no spoiling.</p><p>For <code>SpinMC</code> objects and for <code>GradientSpoiling</code> and <code>RFandGradientSpoiling</code>, <code>workspace isa BlochMcConnellWorkspace</code>. Pass in <code>nothing</code> instead to use an approximate matrix exponential to solve the Bloch-McConnell equation.</p><p><strong>Note</strong></p><p>This function only simulates gradient or ideal spoiling, <em>not</em> RF spoiling. RF spoiling must be implemented by updating the phase of the RF pulse(s) in your sequence from TR to TR.</p><p>For an in-place version, see <a href="#BlochSim.spoil!"><code>spoil!</code></a>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L160-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.spoil!"><a class="docstring-binding" href="#BlochSim.spoil!"><code>BlochSim.spoil!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spoil!(A, B, spin, spoiling, [nothing])
spoil!(A, B, spinmc, spoiling, [workspace])</code></pre><p>Simulate gradient or ideal spoiling, overwriting <code>A</code> and <code>B</code> (in-place version of <a href="#BlochSim.spoil"><code>spoil</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L219-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.spoil!-Union{Tuple{Spin{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#BlochSim.spoil!-Union{Tuple{Spin{T}}, Tuple{T}} where T"><code>BlochSim.spoil!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spoil!(spin)</code></pre><p>Apply ideal spoiling to the given spin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L195-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.spoiler_gradient-Tuple{GradientSpoiling}"><a class="docstring-binding" href="#BlochSim.spoiler_gradient-Tuple{GradientSpoiling}"><code>BlochSim.spoiler_gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spoiler_gradient(spoiling)</code></pre><p>Get the <code>Gradient</code> object used for gradient spoiling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.spoiler_gradient_duration-Tuple{AbstractSpoiling}"><a class="docstring-binding" href="#BlochSim.spoiler_gradient_duration-Tuple{AbstractSpoiling}"><code>BlochSim.spoiler_gradient_duration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spoiler_gradient_duration(spoiling)</code></pre><p>Return the duration of the spoiler gradient (ms).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/spoiling.jl#L142-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.subtract!-Tuple{Magnetization, Magnetization}"><a class="docstring-binding" href="#BlochSim.subtract!-Tuple{Magnetization, Magnetization}"><code>BlochSim.subtract!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subtract!(A, B)</code></pre><p>Compute <code>A - B</code>, storing the result in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L875-L879">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.subtract!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.UniformScaling, BlochMatrix}} where T"><a class="docstring-binding" href="#BlochSim.subtract!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.UniformScaling, BlochMatrix}} where T"><code>BlochSim.subtract!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subtract!(C, A, B)</code></pre><p>Compute <code>A - B</code>, storing the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L897-L901">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.subtractmul!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}"><a class="docstring-binding" href="#BlochSim.subtractmul!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}"><code>BlochSim.subtractmul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subtractmul!(C, X, A, B)</code></pre><p>Compute <code>(X - A) * B</code>, storing the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L1510-L1514">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BlochSim.subtractmuladd!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}"><a class="docstring-binding" href="#BlochSim.subtractmuladd!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}"><code>BlochSim.subtractmuladd!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subtractmuladd!(C, X, A, B)</code></pre><p>Compute <code>(X - A) * B + C</code>, storing the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L1585-L1589">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.mul!-Tuple{Magnetization, Any}"><a class="docstring-binding" href="#LinearAlgebra.mul!-Tuple{Magnetization, Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mul!(A, a)</code></pre><p>Compute <code>A * a</code>, storing the result in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L964-L968">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LinearAlgebra.mul!-Tuple{Magnetization, BlochMatrix, Magnetization}"><a class="docstring-binding" href="#LinearAlgebra.mul!-Tuple{Magnetization, BlochMatrix, Magnetization}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mul!(C, A, B)</code></pre><p>Compute <code>A * B</code>, storing the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/d9171eb74437268e55b4f21dc40f472bee045be7/src/blochmatrix.jl#L999-L1003">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generated/examples/01-overview/">bSSFP »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 11 February 2026 03:56">Wednesday 11 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
