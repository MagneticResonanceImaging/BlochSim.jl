var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [BlochSim]","category":"page"},{"location":"methods/#BlochSim.GAMBAR","page":"Methods","title":"BlochSim.GAMBAR","text":"GAMBAR\n\nGyromagnetic ratio for ¹H with units Hz/G.\n\n\n\n\n\n","category":"constant"},{"location":"methods/#BlochSim.GAMMA","page":"Methods","title":"BlochSim.GAMMA","text":"GAMMA\n\nGyromagnetic ratio for ¹H with units rad/s/G.\n\n\n\n\n\n","category":"constant"},{"location":"methods/#BlochSim.AbstractRF","page":"Methods","title":"BlochSim.AbstractRF","text":"AbstractRF\n\nAbstract type for representing radiofrequency (RF) pulses.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.AbstractSpin","page":"Methods","title":"BlochSim.AbstractSpin","text":"AbstractSpin\n\nAbstract type for representing individual spins.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.AbstractSpoiling","page":"Methods","title":"BlochSim.AbstractSpoiling","text":"AbstractSpoiling\n\nAbstract type for representing spoiling.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochDynamicsMatrix","page":"Methods","title":"BlochSim.BlochDynamicsMatrix","text":"BlochDynamicsMatrix(R1, R2, Δω)\nBlochDynamicsMatrix{T}()\nBlochDynamicsMatrix()\n\nCreate a mutable BlochDynamicsMatrix object.\n\nProperties\n\nR1::Real: Spin-lattice relaxation rate\nR2::Real: Spin-spin relaxation rate\nΔω::Real: Off-resonance frequency\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochMatrix","page":"Methods","title":"BlochSim.BlochMatrix","text":"BlochMatrix(a11, a21, a31, a12, a22, a32, a13, a23, a33)\nBlochMatrix{T}()\nBlochMatrix()\n\nCreate a mutable BlochMatrix object representing a fixed-size 3×3 matrix.\n\nProperties\n\naij::Real: Matrix entry (i,j) ∈ {1, 2, 3}²\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochMcConnellDynamicsMatrix","page":"Methods","title":"BlochSim.BlochMcConnellDynamicsMatrix","text":"BlochMcConnellDynamicsMatrix(A, E)\nBlochMcConnellDynamicsMatrix{T}(N)\nBlochMcConnellDynamicsMatrix(N)\n\nCreate a BlochMcConnellDynamicsMatrix object with N compartments.\n\nProperties\n\nA::NTuple{N,BlochDynamicsMatrix{<:Real}}: List of BlochDynamicsMatrixes that make up the main block diagonal of the BlochMcConnellDynamicsMatrix\nE::NTuple{M,ExchangeDynamicsMatrix{<:Real}}: List of ExchangeDynamicsMatrixes that describe exchange between the different compartments; these matrices make up the remaining M = N^2 - N blocks of the BlochMcConnellDynamicsMatrix, sorted by column-major ordering\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochMcConnellMatrix","page":"Methods","title":"BlochSim.BlochMcConnellMatrix","text":"BlochMcConnellMatrix(A)\nBlochMcConnellMatrix{T}(N)\nBlochMcConnellMatrix(N)\n\nCreate a BlochMcConnellMatrix object with N compartments and representing a fixed-size 3N×3N matrix.\n\nProperties\n\nA::NTuple{N,NTuple{N,BlochMatrix{<:Real}}}: List of 3×3 matrices that comprise the blocks of the BlochMcConnellMatrix; A[i][j] is the (i,j)th block\n\nExamples\n\njulia> B = BlochMcConnellMatrix(3)\nBlochMcConnellMatrix{Float64,3}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> fill!(B, 0.5)\n\njulia> B\nBlochMcConnellMatrix{Float64,3}:\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.ExchangeDynamicsMatrix","page":"Methods","title":"BlochSim.ExchangeDynamicsMatrix","text":"ExchangeDynamicsMatrix(r)\nExchangeDynamicsMatrix{T}()\nExchangeDynamicsMatrix()\n\nCreate a mutable ExchangeDynamicsMatrix object.\n\nProperties\n\nr::Real: Exchange rate from one compartment to another\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.ExcitationMatrix","page":"Methods","title":"BlochSim.ExcitationMatrix","text":"ExcitationMatrix(A)\nExcitationMatrix{T}()\nExcitationMatrix()\n\nCreate an ExcitationMatrix object. Multiplying by a MagnetizationMC object has the effect of multiplying each component of the multi-compartment magnetization by the ExcitationMatrix.\n\nProperties\n\nA::BlochMatrix{<:Real}: Matrix used to describe the excitation\n\nExamples\n\njulia> E = ExcitationMatrix(BlochMatrix(0, 1, 0, 1, 0, 0, 0, 0, 1))\nExcitationMatrix{Int64}:\n 0  1  0\n 1  0  0\n 0  0  1\n\njulia> M = MagnetizationMC((1, 2, 3), (4, 5, 6))\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 1\n  My = 2\n  Mz = 3\n Compartment 2:\n  Mx = 4\n  My = 5\n  Mz = 6\n\njulia> E * M\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 2\n  My = 1\n  Mz = 3\n Compartment 2:\n  Mx = 5\n  My = 4\n  Mz = 6\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.FreePrecessionMatrix","page":"Methods","title":"BlochSim.FreePrecessionMatrix","text":"FreePrecessionMatrix(E1, E2, θ)\nFreePrecessionMatrix{T}()\nFreePrecessionMatrix()\n\nCreate a mutable FreePrecessionMatrix object encoding the effects of relaxation and off-resonance precession.\n\nProperties\n\nE1::Real: T1 relaxation\nE2::Real: T2 relaxation\nθ::Real: Angle of off-resonance precession (rad)\n\nExamples\n\njulia> T1 = 1000; T2 = 100; Δω = π/600; t = 100;\n\njulia> F = FreePrecessionMatrix(exp(-t / T1), exp(-t / T2) * cos(Δω * t), exp(-t / T2) * sin(Δω * t))\nFreePrecessionMatrix{Float64}:\n E1 = 0.9048374180359595\n E2 = 0.31859294158449203\n θ = 0.18393972058572114 rad\n\njulia> Matrix(F)\n3×3 Matrix{Float64}:\n  0.313219  0.058272  0.0\n -0.058272  0.313219  0.0\n  0.0       0.0       0.904837\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Gradient","page":"Methods","title":"BlochSim.Gradient","text":"Gradient(x, y, z)\n\nCreate a Gradient object representing x, y, and z B0 gradients. Units are G/cm.\n\nProperties\n\nx::Real: x gradient\ny::Real: y gradient\nz::Real: z gradient\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.GradientSpoiling","page":"Methods","title":"BlochSim.GradientSpoiling","text":"GradientSpoiling(grad, Tg) <: AbstractSpoiling\nGradientSpoiling(gx, gy, gz, Tg)\n\nRepresents gradient spoiling, e.g., applying a gradient grad = Gradient(gx, gy, gz) for time Tg (ms). grad can be a Gradient (or gx, gy, and gz can be scalars), representing a constant gradient, or grad can be a collection of Gradients (or gx, gy, and gz can be collections of values), representing a gradient waveform with a constant time step.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.IdealSpoiling","page":"Methods","title":"BlochSim.IdealSpoiling","text":"IdealSpoiling() <: AbstractSpoiling\n\nRepresents ideal spoiling, i.e., setting the transverse (x and y) components of a spin's magnetization to 0.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.IdealSpoilingMatrix","page":"Methods","title":"BlochSim.IdealSpoilingMatrix","text":"idealspoiling = IdealSpoilingMatrix()\n\nMatrix representing ideal spoiling. Multiplying by a Magnetization or MagnetizationMC has the effect of setting the x and y components to 0.\n\nExamples\n\njulia> idealspoiling * MagnetizationMC((1, 1, 1), (2, 2, 2))\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 0\n  My = 0\n  Mz = 1\n Compartment 2:\n  Mx = 0\n  My = 0\n  Mz = 2\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.InstantaneousRF","page":"Methods","title":"BlochSim.InstantaneousRF","text":"InstantaneousRF(α, θ = 0) <: AbstractRF\n\nRepresents an idealized instantaneous RF pulse with flip angle α and phase θ.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.MESEBlochSim","page":"Methods","title":"BlochSim.MESEBlochSim","text":"mese! = MESEBlochSim(TR, TE, nechoes, [rfex, rfref, rephaser, crusher, spoiling])\nmese!(spin, [workspace])\n\nSimulate a multi-echo spin echo (MESE) scan on spin, overwriting the spin's magnetization vector. Returns a Vector with the magnetization vectors at each echo.\n\nArguments\n\nTR::Real: Repetition time (ms)\nTE::Real: First echo time, and echo spacing (ms); the first echo time is measured from the middle of the excitation pulse\nnechoes::Integer: Number of echoes to readout\nrfex::AbstractRF = InstantaneousRF(π/2): Excitation RF pulse\nrfref::AbstractRF = InstantaneousRF(π, -π/2): Refocussing RF pulse\nrephaser::Union{<:GradientSpoiling,Nothing} = nothing: Slice-select excitation rephasing gradient\ncrusher::Union{<:GradientSpoiling,Nothing} = nothing: Crusher gradient (placed on either side of each refocussing pulse)\nspoiling::Union{IdealSpoiling,<:GradientSpoiling,Nothing} = IdealSpoiling(): Type of spoiling to apply\n\nworkspace isa MESEBlochSimWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Magnetization","page":"Methods","title":"BlochSim.Magnetization","text":"Magnetization(x, y, z)\nMagnetization{T}()\nMagnetization()\n\nCreate a mutable Magnetization object representing a 3D magnetization vector.\n\nProperties\n\nx::Real: x component of magnetization vector\ny::Real: y component of magnetization vector\nz::Real: z component of magnetization vector\n\nExamples\n\njulia> M = Magnetization()\nMagnetization vector with eltype Float64:\n Mx = 0.0\n My = 0.0\n Mz = 0.0\n\njulia> M.x = 1; M.y = 2; M.z = 3; M\nMagnetization vector with eltype Float64:\n Mx = 1.0\n My = 2.0\n Mz = 3.0\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.MagnetizationMC","page":"Methods","title":"BlochSim.MagnetizationMC","text":"MagnetizationMC((x1, y1, z1), ...)\nMagnetizationMC{T}(N)\nMagnetizationMC(N)\n\nCreate a MagnetizationMC object representing N 3D magnetization vectors in the same physical location.\n\nOne can access the ith component magnetization vector by indexing the MagnetizationMC object. Furthermore, iterating the MagnetizationMC object iterates through each of the component magnetization vectors.\n\nProperties\n\nM::NTuple{N,Magnetization{<:Real}}: List of component magnetization vectors\n\nExamples\n\njulia> M = MagnetizationMC((1, 2, 3), (4, 5, 6))\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 1\n  My = 2\n  Mz = 3\n Compartment 2:\n  Mx = 4\n  My = 5\n  Mz = 6\n\njulia> M[2]\nMagnetization vector with eltype Int64:\n Mx = 4\n My = 5\n Mz = 6\n\njulia> foreach(m -> (m.x = 0; m.y = 1; m.z = 2), M)\n\njulia> M\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 0\n  My = 1\n  Mz = 2\n Compartment 2:\n  Mx = 0\n  My = 1\n  Mz = 2\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Position","page":"Methods","title":"BlochSim.Position","text":"Position(x, y, z)\n\nCreate a mutable Position object representing a 3D location. Units are cm.\n\nProperties\n\nx::Real: x position\ny::Real: y position\nz::Real: z position\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.RF","page":"Methods","title":"BlochSim.RF","text":"RF(waveform, Δt, [Δθ], [grad]) <: AbstractRF\n\nRepresents an RF pulse with the given (possibly complex-valued) waveform (G) and time step Δt (ms). Δθ is additional phase added to the waveform (defaults to 0), and grad is the B0 gradient that is turned on during the RF pulse (defaults to Gradient(0, 0, 0), i.e., turned off).\n\nProperties\n\nα::Vector{<:Real}: Instantaneous flip angles (rad) at each time point; computed from the magnitude of waveform\nθ::Vector{<:Real}: Instantaneous phase (rad) at each time point; computed from the phase of waveform\nΔt::Real: Time step (ms)\nΔθ_initial::Real: Phase added to θ before any phase-cycling increment has been applied\nΔθ::Ref{<:Real}: Phase to be added to θ; can be updated to simulate phase-cycling/RF spoiling\ngrad: Gradient applied during the RF pulse\n::Gradient: Constant gradient\n::Vector{<:Gradient}: Time-varying gradient\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.RFSpoiling","page":"Methods","title":"BlochSim.RFSpoiling","text":"RFSpoiling(Δθ = 117°) <: AbstractSpoiling\n\nRepresents RF spoiling, i.e., quadratically incrementing the phase of the RF pulses from TR to TR.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.RFandGradientSpoiling","page":"Methods","title":"BlochSim.RFandGradientSpoiling","text":"RFandGradientSpoiling(grad_spoiling, rf_spoiling) <: AbstractSpoiling\n\nRepresents both RF and gradient spoiling.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.SPGRBlochSim","page":"Methods","title":"BlochSim.SPGRBlochSim","text":"spgr! = SPGRBlochSim(TR, TE, rf, [spoiling], [nTR], [save_transients])\nspgr!(spin, [workspace])\n\nSimulate a spoiled gradient-recalled echo (SPGR) scan on spin, overwriting the spin's magnetization vector. The resultant magnetization is stored in spin.M. If nTR > 0 and save_transients === true, then spgr!(...) returns a Vector with the magnetization vectors at the echo time for each of the nTR simulated TRs.\n\nArguments\n\nTR::Real: Repetition time (ms)\nTE::Real: Echo time (ms)\nrf:\n::Real: Excitation flip angle (rad) (assumes an instantaneous RF pulse)\n::AbstractRF: Excitation RF pulse\nspoiling::AbstractSpoiling = IdealSpoiling(): Type of spoiling to apply\nnTR::Val = Val(0): Number of TRs to simulate; Val(0) indicates to simulate a steady-state scan\nsave_transients::Val = Val(false): Whether or not to return the magnetization vectors at the TE for each of the nTR simulated TRs; does nothing if nTR == 0\n\nworkspace isa SPGRBlochSimWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Spin","page":"Methods","title":"BlochSim.Spin","text":"Spin([M], M0, T1, T2, Δf, [pos]) <: AbstractSpin\n\nCreate an object that represents a single spin.\n\nProperties\n\nM::Magnetization = Magnetization(0, 0, M0): Magnetization vector\nM0::Real: Equilibrium magnetization\nT1::Real: Spin-lattice recovery time constant (ms)\nT2::Real: Spin-spin recovery time constant (ms)\nΔf::Real: Off-resonance frequency (Hz)\npos::Position = Position(0, 0, 0): Spatial location (cm)\nN::Int = 1: Number of compartments\n\nExamples\n\njulia> Spin(1, 1000, 100, 0, Position(1, 2, 3))\nSpin{Float64}:\n M = Magnetization(0.0, 0.0, 1.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 0.0 Hz\n pos = Position(1.0, 2.0, 3.0) cm\n\njulia> Spin(Magnetization(1, 2, 3), 1, 1000, 100, 0)\nSpin{Float64}:\n M = Magnetization(1.0, 2.0, 3.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 0.0 Hz\n pos = Position(0.0, 0.0, 0.0) cm\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.SpinMC","page":"Methods","title":"BlochSim.SpinMC","text":"SpinMC([M], M0, frac, T1, T2, Δf, τ, [pos]) <: AbstractSpin\n\nCreate an object that represents a single spin with multiple compartments.\n\nProperties\n\nM::MagnetizationMC = Meq: Magnetization vector\nMeq::MagnetizationMC = MagnetizationMC((0, 0, frac[1] * M0), ...): Equilibrium magnetization vector\nM0::Real: Equilibrium magnetization\nfrac::Tuple{<:Real}: Water fraction of each compartment\nT1::Tuple{<:Real}: Spin-lattice recovery time constants (ms)\nT2::Tuple{<:Real}: Spin-spin recovery time constants (ms)\nΔf::Tuple{<:Real}: Off-resonance frequencies (Hz)\nr::Tuple{Tuple{<:Real}}: Exchange rates (1/ms); r[i][j] is the exchange rate from compartment i to compartment j\npos::Position = Position(0, 0, 0): Spatial location (cm)\nN::Int = length(frac): Number of compartments\n\nNote\n\nThe SpinMC constructor takes τ (inverse exchange rate, or residence time) as input, not r. Furthermore, τ is given as a Tuple with N^2 - N elements, arranged like (τ12, τ13, ..., τ1N, τ21, τ23, ..., τ2N, ...).\n\nExamples\n\njulia> SpinMC(1, (0.2, 0.8), (400, 1000), (20, 100), (15, 0), (100, 25))\nSpinMC{Float64,2}:\n M = MagnetizationMC((0.0, 0.0, 0.2), (0.0, 0.0, 0.8))\n M0 = 1.0\n frac = (0.2, 0.8)\n T1 = (400.0, 1000.0) ms\n T2 = (20.0, 100.0) ms\n Δf = (15.0, 0.0) Hz\n r = ((0.0, 0.01), (0.04, 0.0)) 1/ms\n pos = Position(0.0, 0.0, 0.0) cm\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.absolutesum-Tuple{BlochSim.BlochDynamicsMatrix}","page":"Methods","title":"BlochSim.absolutesum","text":"absolutesum(A)\n\nCompute the sum of the absolute values of the elements of A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.add!-Tuple{AbstractVector, Magnetization, Magnetization}","page":"Methods","title":"BlochSim.add!","text":"add!(C, A, B)\n\nCompute A + B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.add!-Tuple{Magnetization, Magnetization}","page":"Methods","title":"BlochSim.add!","text":"add!(A, B)\n\nCompute A + B, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.applydynamics!-Tuple{AbstractSpin, Any, Any, Any}","page":"Methods","title":"BlochSim.applydynamics!","text":"applydynamics!(spin, BtoM, A, [B])\n\nApply dynamics to the given spin, overwriting the spin's magnetization vector. BtoM is used to store intermediate results (and is thus overwritten).\n\nExamples\n\njulia> s = Spin(1, 1000, 100, 3.75); s.M\nMagnetization vector with eltype Float64:\n Mx = 0.0\n My = 0.0\n Mz = 1.0\n\njulia> BtoM = Magnetization();\n\njulia> (A,) = excite(s, InstantaneousRF(π/2)); applydynamics!(s, BtoM, A); s.M\nMagnetization vector with eltype Float64:\n Mx = 1.0\n My = 0.0\n Mz = 6.123233995736766e-17\n\njulia> (A, B) = freeprecess(s, 100); applydynamics!(s, BtoM, A, B); s.M\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404054\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.combine!-NTuple{6, Any}","page":"Methods","title":"BlochSim.combine!","text":"combine!(A, B, A1, B1, A2, B2)\ncombine!(A, A1, A2)\n\nCombine the matrices and vectors that describe the dynamics of a spin into one matrix and one vector, overwriting A and B. The dynamics described by A1 and B1 apply first, then those described by A2 and B2. In other words, A = A2 * A1 and B = A2 * B1 + B2.\n\nExamples\n\njulia> s = Spin(1, 1000, 100, 3.75);\n\njulia> A = BlochMatrix(); B = Magnetization();\n\njulia> (A1, B1) = excite(s, InstantaneousRF(π/2));\n\njulia> (A2, B2) = freeprecess(s, 100);\n\njulia> combine!(A, B, A1, B1, A2, B2); A * s.M + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404054\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.div!-Tuple{Magnetization, Any}","page":"Methods","title":"BlochSim.div!","text":"div!(A, a)\n\nCompute A / a, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.duration-Tuple{InstantaneousRF}","page":"Methods","title":"BlochSim.duration","text":"duration(rf)\n\nReturn the duration (ms) of the RF pulse.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.excite","page":"Methods","title":"BlochSim.excite","text":"excite(spin, rf::InstantaneousRF, [nothing])\nexcite(spin, rf::RF, [workspace])\n\nSimulate excitation for the given spin. Returns (A, B) such that A * M + B applies excitation to the magnetization M. If isnothing(B) (as is the case for InstantaneousRFs), then A * M applies excitation to M.\n\nFor RF objects, workspace isa ExcitationWorkspace. For SpinMC objects, use workspace = ExcitationWorkspace(spin, nothing) to use an approximate matrix exponential to solve the Bloch-McConnell equation.\n\nFor an in-place version, see excite!.\n\nExamples\n\njulia> s = Spin(1, 1000, 100, 3.75); s.M\nMagnetization vector with eltype Float64:\n Mx = 0.0\n My = 0.0\n Mz = 1.0\n\njulia> (A,) = excite(s, InstantaneousRF(π/2, π/4)); A * s.M\nMagnetization vector with eltype Float64:\n Mx = 0.7071067811865476\n My = -0.7071067811865475\n Mz = 6.123233995736766e-17\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.excite!-Tuple{AbstractSpin, Vararg{Any}}","page":"Methods","title":"BlochSim.excite!","text":"excite!(spin, ...)\n\nApply excitation to the given spin, overwriting the spin's magnetization vector.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.excite!-Tuple{ExcitationMatrix, AbstractSpin, InstantaneousRF}","page":"Methods","title":"BlochSim.excite!","text":"excite!(A, [nothing], spin, rf::InstantaneousRF, [nothing])\nexcite!(A, B, spin, rf::RF, [workspace])\n\nSimulate excitation, overwriting A and B (in-place version of excite).\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.expm!-Union{Tuple{M}, Tuple{N}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}, BlochSim.MatrixExponentialWorkspace{T3, N}}} where {T1, T2, T3, N, M}","page":"Methods","title":"BlochSim.expm!","text":"expm!(expA, A, [workspace])\n\nCompute the matrix exponential of A, storing it in expA.\n\nworkspace isa MatrixExponentialWorkspace.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.freeprecess","page":"Methods","title":"BlochSim.freeprecess","text":"freeprecess(spin, t, [nothing])\nfreeprecess(spinmc, t, [workspace])\nfreeprecess(spin, t, grad, [nothing])\nfreeprecess(spinmc, t, grad, [workspace])\n\nSimulate free-precession for the given spin for time t ms, optionally in the presence of a B0 gradient. Returns (A, B) such that A * M + B applies free-precession to the magnetization M.\n\nFor SpinMC objects, workspace isa BlochMcConnellWorkspace. Pass in nothing instead to use an approximate matrix exponential to solve the Bloch-McConnell equation.\n\nFor an in-place version, see freeprecess!.\n\nExamples\n\njulia> s = Spin(Magnetization(1, 0, 0), 1, 1000, 100, 3.75)\nSpin{Float64}:\n M = Magnetization(1.0, 0.0, 0.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 3.75 Hz\n pos = Position(0.0, 0.0, 0.0) cm\n\njulia> (A, B) = freeprecess(s, 100); A * s.M + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404048\n\njulia> s = Spin(Magnetization(1, 0, 0), 1, 1000, 100, 0, Position(0, 0, 3.75))\nSpin{Float64}:\n M = Magnetization(1.0, 0.0, 0.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 0.0 Hz\n pos = Position(0.0, 0.0, 3.75) cm\n\njulia> (A, B) = freeprecess(s, 100, Gradient(0, 0, 1/GAMBAR)); A * s.M + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404048\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.freeprecess!-NTuple{7, Any}","page":"Methods","title":"BlochSim.freeprecess!","text":"freeprecess!(A, B, t, M0, T1, T2, Δf)\nfreeprecess!(A, B, spin, t, [nothing])\nfreeprecess!(A, B, spinmc, t, [workspace])\nfreeprecess!(A, B, spin, t, grad, [nothing])\nfreeprecess!(A, B, spinmc, t, grad, [workspace])\n\nSimulate free-precession, overwriting A and B (in-place version of freeprecess).\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.freeprecess!-Tuple{AbstractSpin, Vararg{Any}}","page":"Methods","title":"BlochSim.freeprecess!","text":"freeprecess!(spin, ...)\n\nApply free-precession to the given spin, overwriting the spin's magnetization vector.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.freeprecess-NTuple{5, Real}","page":"Methods","title":"BlochSim.freeprecess","text":"freeprecess(t, M0, T1, T2, Δf)\n\nSimulate free-precession, i.e., relaxation and off-resonance precession. Returns (A, B) such that A * M + B applies free-precession to the magnetization M.\n\nFor an in-place version, see freeprecess!.\n\nArguments\n\nt::Real: Duration of free-precession (ms)\nM0::Real: Equilibrium magnetization\nT1::Real: Spin-lattice recovery time constant (ms)\nT2::Real: Spin-spin recovery time constant (ms)\nΔf::Real: Off-resonance frequency (Hz)\n\nExamples\n\njulia> (A, B) = freeprecess(100, 1, 1000, 100, 3.75); A * Magnetization(1, 0, 0) + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404048\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.gradient_frequency-Tuple{Gradient, Position}","page":"Methods","title":"BlochSim.gradient_frequency","text":"gradient_frequency(grad, pos)\n\nCompute the off-resonance frequency in Hz induced by the given B0 gradient grad at position pos.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.muladd!-Tuple{Magnetization, BlochMatrix, Magnetization}","page":"Methods","title":"BlochSim.muladd!","text":"muladd!(C, A, B)\n\nCompute A * B + C, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.rfspoiling_increment-Tuple{AbstractSpoiling}","page":"Methods","title":"BlochSim.rfspoiling_increment","text":"rfspoiling_increment(spoiling)\n\nReturn the quadratic phase increment used for RF spoiling.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.rotatetheta","page":"Methods","title":"BlochSim.rotatetheta","text":"rotatetheta(α::Real = π/2, θ::Real = 0)\n\nReturn a 3 × 3 BlochMatrix for (left-handed) flip angle α about an axis in the x-y plane that makes (left-handed) angle θ with the negative y-axis.\n\nFor an in-place version, see rotatetheta!.\n\nExamples\n\njulia> BlochSim.rotatetheta() * Magnetization(0, 0, 1) # Rotate towards positive x-axis\nMagnetization vector with eltype Float64:\n Mx = 1.0\n My = 0.0\n Mz = 6.123233995736766e-17\n\njulia> BlochSim.rotatetheta(π/2, π/2) * Magnetization(0, 0, 1) # Rotate towards negative y-axis\nMagnetization vector with eltype Float64:\n Mx = 6.123233995736766e-17\n My = -1.0\n Mz = 6.123233995736766e-17\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.rotatetheta!-Tuple{Any, Any, Any}","page":"Methods","title":"BlochSim.rotatetheta!","text":"rotatetheta!(A, α, θ)\n\nSimulate left-handed rotation by angle α about an axis in the x-y plane that makes left-handed angle θ with the negative y-axis, overwriting A.\n\nThis function is an in-place version of rotatetheta.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.signal-Tuple{Magnetization}","page":"Methods","title":"BlochSim.signal","text":"signal(spin)\nsignal(M)\n\nReturn the signal detected from the given spin or magnetization vector.\n\nExamples\n\njulia> signal(Spin(Magnetization(1, 2, 3), 1, 1000, 100, 0))\n1.0 + 2.0im\n\njulia> signal(MagnetizationMC((1, 2, 3), (1, 1, 1)))\n2 + 3im\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.spoil","page":"Methods","title":"BlochSim.spoil","text":"spoil(spin, spoiling, [nothing])\nspoil(spinmc, spoiling, [workspace])\n\nSimulate gradient or ideal spoiling for the given spin. Returns (A, B), such that A * M + B applies spoiling to the magnetization M. If B is nothing (as is the case for IdealSpoiling), then A * M applies spoiling, and if both A and B are nothing (as is the case for RFSpoiling) then there is no spoiling.\n\nFor SpinMC objects and for GradientSpoiling and RFandGradientSpoiling, workspace isa BlochMcConnellWorkspace. Pass in nothing instead to use an approximate matrix exponential to solve the Bloch-McConnell equation.\n\nNote\n\nThis function only simulates gradient or ideal spoiling, not RF spoiling. RF spoiling must be implemented by updating the phase of the RF pulse(s) in your sequence from TR to TR.\n\nFor an in-place version, see spoil!. ```\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.spoil!","page":"Methods","title":"BlochSim.spoil!","text":"spoil!(A, B, spin, spoiling, [nothing])\nspoil!(A, B, spinmc, spoiling, [workspace])\n\nSimulate gradient or ideal spoiling, overwriting A and B (in-place version of spoil).\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.spoil!-Union{Tuple{Spin{T}}, Tuple{T}} where T","page":"Methods","title":"BlochSim.spoil!","text":"spoil!(spin)\n\nApply ideal spoiling to the given spin.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.spoiler_gradient-Tuple{GradientSpoiling}","page":"Methods","title":"BlochSim.spoiler_gradient","text":"spoiler_gradient(spoiling)\n\nGet the Gradient object used for gradient spoiling.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.spoiler_gradient_duration-Tuple{AbstractSpoiling}","page":"Methods","title":"BlochSim.spoiler_gradient_duration","text":"spoiler_gradient_duration(spoiling)\n\nReturn the duration of the spoiler gradient (ms).\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtract!-Tuple{Magnetization, Magnetization}","page":"Methods","title":"BlochSim.subtract!","text":"subtract!(A, B)\n\nCompute A - B, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtract!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.UniformScaling, BlochMatrix}} where T","page":"Methods","title":"BlochSim.subtract!","text":"subtract!(C, A, B)\n\nCompute A - B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtractmul!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}","page":"Methods","title":"BlochSim.subtractmul!","text":"subtractmul!(C, X, A, B)\n\nCompute (X - A) * B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtractmuladd!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}","page":"Methods","title":"BlochSim.subtractmuladd!","text":"subtractmuladd!(C, X, A, B)\n\nCompute (X - A) * B + C, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearAlgebra.mul!-Tuple{Magnetization, Any}","page":"Methods","title":"LinearAlgebra.mul!","text":"mul!(A, a)\n\nCompute A * a, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearAlgebra.mul!-Tuple{Magnetization, BlochMatrix, Magnetization}","page":"Methods","title":"LinearAlgebra.mul!","text":"mul!(C, A, B)\n\nCompute A * B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"EditURL = \"../../../lit/examples/01-overview.jl\"","category":"page"},{"location":"generated/examples/01-overview/#bssfp","page":"bSSFP","title":"bSSFP","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"This page illustrates using the Julia package BlochSim to calculate MRI signals for balanced steady-state free precession (bSSFP) pulse sequences.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"This demo facilitates understanding bSSFP sequences, multi-compartment spins, and myelin water exchange.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"This demo recreates Figure 3 from [1] and Figure 2 from [2].","category":"page"},{"location":"generated/examples/01-overview/#References","page":"bSSFP","title":"References","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"[1] Hargreaves, B., Vasanawala, S., Pauly, J., & Nishimura, D. (2001). Characterization and reduction of the transient response in steady‐state MR imaging. MRM 46(1), 149-158.\n[2] Murthy, N., Nielsen, J., Whitaker, S., Haskell, M., Swanson, S., Seiberlich, N., & Fessler, J. (2022). Quantifying myelin water exchange using optimized bSSFP sequences. Proc. Intl. Soc. Mag. Res. Med (p. 2068).\n[3] Hinshaw, W. S. (1976). Image formation by nuclear magnetic resonance: the sensitive‐point method. J. of Applied Physics, 47(8), 3709-21.\n[4] Whitaker, S. T., Nataraj, G., Nielsen, J. F., & Fessler, J. A. (2020). Myelin water fraction estimation using small‐tip fast recovery MRI. MRM 84(4), 1977-90.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"This page comes from a single Julia file: 01-overview.jl.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"page"},{"location":"generated/examples/01-overview/#Setup","page":"bSSFP","title":"Setup","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"First we add the Julia packages that are need for this demo. Change false to true in the following code block if you are using any of the following packages for the first time.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"if false\n    import Pkg\n    Pkg.add([\n        \"BlochSim\"\n        \"LaTeXStrings\"\n        \"LinearAlgebra\"\n        \"Plots\"\n    ])\nend","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Tell this Julia session to use the following packages for this example. Run Pkg.add() in the preceding code block first, if needed.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"using BlochSim: Spin, SpinMC, InstantaneousRF, excite, freeprecess\nusing InteractiveUtils: versioninfo\nusing LaTeXStrings: latexstring\nusing LinearAlgebra: I\nusing MIRTjim: prompt\nusing Plots: plot, plot!, default\ndefault(titlefontsize = 10, markerstrokecolor = :auto, label=\"\")","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"isinteractive() || prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Define some useful helper functions.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Hz_to_kHz(Δf_Hz) = Δf_Hz * 10^(-3) # convert frequencies in Hz to kHz\nkHz_to_Hz(Δf_kHz) = Δf_kHz * 10^(3) # convert frequencies in kHz to Hz","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"The bSSFP pulse sequence in Figure 2 in [1] starts with a RF pulse, then","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"a is at time TE\nb is TR-TE later, right before next RF pulse\nc is immediately after the next RF pulse\nd is TE after that next RF pulse","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"We use this to generate Figure 3 in [1] in two different ways. The RF excitation is repeated periodically and, in steady-state, the magnetization at point a is the same as at point d.","category":"page"},{"location":"generated/examples/01-overview/#Method-1:-Use-matrices","page":"bSSFP","title":"Method 1: Use matrices","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Use Equations 1 and 2 and Appendix A from [1]","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Calculate the steady-state value at point d using the method from [1] using Equations 1 and 2 and Appendix A.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"\"\"\"\n    bssfp_matrix(α_deg, TR_ms, TE_ms, mo, T1_ms, T2_ms, Δf_kHz=0)\n\nReturn steady-state magnetization signal value\nat the echo time\nfor a bSSFP sequence\nusing method of\n[Hargreaves et al., MRM 2001](https://doi.org/10.1002/mrm.1170).\n\n# In\n- `α_deg` flip angle of RF pulse (degrees)\n- `TR_ms` repetition time (ms)\n- `TE_ms` echo time (ms)\n- `mo` initial condition for magnetization in the z-direction (constant)\n- `T1_ms` MRI tissue parameter for T1 relaxation (ms)\n- `T2_ms` MRI tissue parameter for T2 relaxation (ms)\n- `Δf_Hz` off-resonance value (Hz)\n\n# Out\n- `signal` steady-state magnetization (as a complex number)\n\"\"\"\nfunction bssfp_matrix(α_deg, TR_ms, TE_ms, mo, T1_ms, T2_ms, Δf_Hz=0)\n\n    Δf_kHz = Hz_to_kHz(Δf_Hz) # convert off-resonance value to kHz\n\n    M0 = [0; 0; mo] # initial magnetization vector\n\n    α_rad = deg2rad(α_deg) # convert flip angle α from degrees to radians\n\n    # rotation matrix for RF excitation about the x-axis\n    R = [1 0 0; 0 cos(α_rad) sin(α_rad); 0 -sin(α_rad) cos(α_rad)]\n\n    # free precession matrix\n    P(τ_ms) = [cos(2π*Δf_kHz*τ_ms) sin(2π*Δf_kHz*τ_ms) 0 ; -sin(2π*Δf_kHz*τ_ms) cos(2π*Δf_kHz*τ_ms) 0 ; 0 0 1]\n\n    # matrices for T1 and T2 relaxation over a time τ\n    C(τ_ms) = [exp(-τ_ms/T2_ms) 0 0 ; 0 exp(-τ_ms/T2_ms) 0 ; 0 0 exp(-τ_ms/T1_ms)]\n    D(τ_ms) = (I - C(τ_ms)) * [0 ; 0 ; mo]\n\n    # matrices for various values of τ\n    P1 = P(TE_ms)\n    P2 = P(TR_ms - TE_ms)\n    C1 = C(TE_ms)\n    C2 = C(TR_ms - TE_ms)\n    D1 = D(TE_ms)\n    D2 = D(TR_ms - TE_ms)\n\n    # matrix A and vector b for steady-state calculation\n    A = P1*C1*R*P2*C2\n    b = P1*C1*R*D2 + D1\n\n    Mss = (I - A) \\ b # steady-state magnetization\n\n    return complex(Mss[1], Mss[2]) # return the complex signal\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/#Method-2:-Use-BlochSim","page":"bSSFP","title":"Method 2: Use BlochSim","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"\"\"\"\n    bssfp_blochsim(α_deg, TR_ms, TE_ms, mo, T1_ms, T2_ms, Δf_kHz=0)\n    bssfp_blochsim(α_deg, TR_ms, TE_ms, spin)\n\nReturn steady-state magnetization signal value\nat the echo time\nfor a bSSFP sequence\nusing BlochSim.\nSee [Hargreaves et al., MRM 2001](https://doi.org/10.1002/mrm.1170).\n\n# In\n- `α_deg` flip angle of RF pulse (degrees)\n- `TR_ms` repetition time (ms)\n- `TE_ms` echo time (ms)\n- `mo` initial condition for magnetization in the z-direction (constant)\n- `T1_ms` MRI tissue parameter for T1 relaxation (ms)\n- `T2_ms` MRI tissue parameter for T2 relaxation (ms)\n- `Δf_Hz` off-resonance value (Hz)\n\n# Out\n- `signal` steady-state magnetization (as a complex number)\n\"\"\"\nfunction bssfp_blochsim(α_deg, TR_ms, TE_ms, mo, T1_ms, T2_ms, Δf_Hz=0)\n    spin = Spin(mo, T1_ms, T2_ms, Δf_Hz) # create a spin\n    return bssfp_blochsim(α_deg, TR_ms, TE_ms, spin)\nend;\n\n\nfunction bssfp_blochsim(α_deg, TR_ms, TE_ms, spin::Spin)\n\n    α_rad = deg2rad(α_deg) # convert flip angle α from degrees to radians\n\n    #=\n    excite the spin\n    include RF phase for instantaneous RF because above code flips over x axis\n    and blochsim flips over -y axis and want to make them consistent\n    =#\n    (R,) = excite(spin, InstantaneousRF(α_rad, -π/2))\n    R = Matrix(R.A)\n\n    # put spin through precession/relaxation for various time period values\n    (PC1_A, PC1_B) = freeprecess(spin, TE_ms)\n    (PC2_A, PC2_B) = freeprecess(spin, TR_ms-TE_ms)\n    (PC_TR_A, PC_TR_B) = freeprecess(spin, TR_ms)\n\n    # calculate the A and B matrices\n    A = Matrix(PC1_A)*R*Matrix(PC2_A)\n    B = Matrix(PC1_A)*R*Vector(PC2_B)+Vector(PC1_B)\n\n    # calculate the steady-state magnetization at the echo time\n    Mss = (I - A) \\ B\n\n    return complex(Mss[1], Mss[2]) # return the complex signal\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/#Recreate-Figure-3-from-[1]-using-Methods-1-and-2","page":"bSSFP","title":"Recreate Figure 3 from [1] using Methods 1 and 2","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"TR_ms, TE_ms = 10, 5 # scan parameters\nmo, T1_ms, T2_ms = 1, 400, 100 # tissue parameters\n\nnum_off_res_values = 401 # array of off-resonance values\nΔf_arr_kHz = range(-1/TR_ms, 1/TR_ms, num_off_res_values) # 2 periods\n\nflip_ang_arr_deg = [15, 30, 60, 90] # array of flip angles\nnum_flip_angles = length(flip_ang_arr_deg);\n\n# array to store calculated results for both plots (methods 1 and 2)\nnum_plots = 2\nsig_arr = zeros(num_flip_angles, num_off_res_values, num_plots)\n\np_m = plot(title=\"Matrix Version\") # initialize plots\np_b = plot(title=\"BlochSim Version\");\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Call bssfp_matrix and bssfp_blochsim for various flip angles and off-resonance values","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"for i in 1:num_flip_angles # iterate over flip angles\n    α_deg = flip_ang_arr_deg[i]\n\n    for j in 1:num_off_res_values # iterate over off-resonance values\n        Δf_kHz = Δf_arr_kHz[j]\n\n        local Δf_Hz = kHz_to_Hz(Δf_kHz) # convert from kHz to Hz\n\n        # call both implementations (methods 1 and 2) of bSSFP signal model\n        signal_matrix = bssfp_matrix(α_deg, TR_ms, TE_ms, mo, T1_ms, T2_ms, Δf_Hz)\n        signal_blochsim = bssfp_blochsim(α_deg, TR_ms, TE_ms, mo, T1_ms, T2_ms, Δf_Hz)\n        @assert signal_blochsim ≈ signal_matrix # check!\n\n        # save results for methods 1 and 2\n        sig_arr[i,j,1] = abs(signal_matrix)\n        sig_arr[i,j,2] = abs(signal_blochsim)\n    end\n\n    # plot results for current flip angle\n    plot!(p_m, 1000Δf_arr_kHz, sig_arr[i,:,1], label=\"α = $(α_deg)°\")\n    plot!(p_b, 1000Δf_arr_kHz, sig_arr[i,:,2], label=\"α = $(α_deg)°\")\nend","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Plot results and label axes:","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"p1 = plot(p_m, p_b, layout = (2,1),\n    xlabel = \"Resonant Frequency (Hz)\",\n    ylabel = \"Signal Magnitude\",\n    plot_title = \"Steady-State Signal Magnitude vs. Resonant Frequency\",\n    plot_titlefontsize = 12,\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"prompt()","category":"page"},{"location":"generated/examples/01-overview/#Multi-compartment-spins-and-myelin-water-exchange","page":"bSSFP","title":"Multi-compartment spins and myelin water exchange","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Generate Figure 2 from [2] using BlochSim. First define some useful helper functions. These functions put the parameters in the correct format for the multi-compartment spin object constructors.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"\"\"\"\n- in: `f_f` fast fraction (myelin fraction)\n- out: `mwf_tuple` tuple with fast and slow fractions\n\"\"\"\nget_mwf_tuple(f_f) = (f_f, 1-f_f)\n\n\n\"\"\"\n# In:\n- `τ_fs_ms` residence time for exchange from myelin to non-myelin water (ms)\n- `f_f` fast fraction (myelin fraction)\n# Out:\n- `τ_tuple_ms` tuple with fast-to-slow and slow-to-fast residence times\n\"\"\"\nfunction get_τ_tuple(τ_fs_ms, f_f)\n    τ_sf_ms = (1-f_f) * τ_fs_ms / f_f\n    τ_tuple_ms = (τ_fs_ms, τ_sf_ms)\n    return τ_tuple_ms\nend\n\n\n\"\"\"\n# In:\n- `ΔΦ_rad` RF phase cycling value (radians)\n- `Δf_Hz` off-resonance value (Hz)\n- `Δf_myelin_Hz` # additional off-resonance value only experienced by myelin water (Hz)\n- `TR_ms` repetition time (ms)\n# Out:\n- `Δf_tuple_Hz` tuple with off-resonance values for fast and slow compartments\n\n[Hinshaw, J. Appl. Phys. 1976](https://doi.org/10.1063/1.323136).\n\"\"\"\nfunction get_Δf_tuple(ΔΦ_rad, Δf_Hz, Δf_myelin_Hz, TR_ms)\n\n    # convert the RF phase cycling value to Hz from radians\n    ΔΦ_Hz = kHz_to_Hz((ΔΦ_rad)/(2π*TR_ms))\n\n    # subtract the RF phase cycling value from the off-resonance value\n    Δf_RF_Hz = Δf_Hz - ΔΦ_Hz\n\n    # add the myelin off-resonance for the myelin term\n    Δf_myelin_RF_Hz = Δf_RF_Hz + Δf_myelin_Hz\n\n    # create and return tuple for the spin object constructor\n    Δf_tuple_Hz = (Δf_myelin_RF_Hz, Δf_RF_Hz)\n    return Δf_tuple_Hz\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Define a function similar to Method 2 above, but for multi-compartment spin objects.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"\"\"\"\n    bssfp_blochsim_MC(α_deg, TR_ms, TE_ms, spin_mc, spin_mc_no_rf_phase_fact)\n\nReturn steady-state magnetization signal value\nat the echo time\nfor a bSSFP sequence\nusing BlochSim.\n\nRef: Murthy, N., Nielsen, J. F., Whitaker, S. T., Haskell, M. W.,\nSwanson, S. D., Seiberlich, N., & Fessler, J. A. (2022).\nQuantifying myelin water exchange using optimized bSSFP\nsequences. In Proc. Intl. Soc. Mag. Res. Med (p. 2068). [2]\n\n# In\n- `α_deg` flip angle of RF pulse (degrees)\n- `TR_ms` repetition time (ms)\n- `TE_ms` echo time (ms)\n- 'spin_mc' multi-compartment spin object with RF phase cycling factor\n- 'spin_mc_no_rf_phase_fact' multi-compartment spin object without RF phase cycling factor\n\n# Out\n- `signal` steady-state magnetization (as a complex number)\n\"\"\"\nfunction bssfp_blochsim_MC(α_deg, TR_ms, TE_ms, spin_mc, spin_mc_no_rf_phase_fact)\n\n    # convert flip angle α from degrees to radians\n    α_rad = deg2rad(α_deg)\n\n    # excite the spin and reshape R to be the correct dimensions for a SpinMC object\n    (R,) = excite(spin_mc, InstantaneousRF(α_rad))\n    R = Matrix(R.A)\n    R = kron(I(2),R)\n\n    # precession/relaxation of the spin for TR\n    (PC_TR_A, PC_TR_B) = freeprecess(spin_mc, TR_ms)\n\n    # precession/relaxation of the spin for TE\n    # assume receiver modulates signal and uses the receiver phase as the RF phase\n    (PC_TE_A, PE_TE_B) = freeprecess(spin_mc_no_rf_phase_fact, TE_ms)\n\n    # calculate A matrix and b vector\n    A = Matrix(PC_TR_A) * R\n    b = Vector(PC_TR_B)\n\n    Mss = (I - A) \\ b # steady-state just before tip down\n    M = R * Mss # magnetization after tip-down\n\n    # steady-state magnetization at the echo time\n    M = Matrix(PC_TE_A) * M + Vector(PE_TE_B)\n\n    return (complex(M[1]+M[4], M[2]+M[5])) # return the complex signal\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Define variables to be used in the following plots. Values taken from [2] and [4].","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"mo = 0.77; # initial condition for longitudinal magnetization (constant)\n\n# T1 and T2 values\nT1_f_ms = 400 # T1 for fast-relaxing, myelin water compartment\nT1_s_ms = 832 # T1 for slow-relaxing, non-myelin water compartment\nT1_ms_tuple = (T1_f_ms, T1_s_ms);\n\nT2_f_ms = 20 # T2 for fast-relaxing, myelin water compartment\nT2_s_ms = 80 # T2 for slow-relaxing, non-myelin water compartment\nT2_ms_tuple = (T2_f_ms, T2_s_ms)\n\nΔf_myelin_Hz = 5.0 # frequency shift of myelin water\n\nf_f = 0.15 # myelin water fraction (MWF), fast fraction\nmwf_tuple = get_mwf_tuple(f_f) # tuple with fast and slow relaxing fractions\n\nTR_ms, TE_ms = 20, 4; # scan parameters\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Generate plots similar to Figure 3 from [1] but with three different RF phase cycling factor values: (0, 90, and 180 degrees).","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"For this example, choose one exchange rate:","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"τ_fs = 50.0 # this will be varied in the next plot\n\n# tuple with fast-to-slow and slow-to-fast residence times\nτ_tuple_ms = get_τ_tuple(τ_fs, f_f)\n\nnum_samples = 401 # number of samples (resonant frequencies)\n\nflip_ang_arr_deg = [10, 40] # flips angles for example\nnum_flip_angles = length(flip_ang_arr_deg)\n\nΔΦ_arr_deg = [0, 90, 180] # RF phase cycling value (degrees)\nΔϕ_arr_marker = [:circle :star5 :utriangle]\nnum_phases = length(ΔΦ_arr_deg);\n\n# array to store results\nsig_arr = zeros(num_flip_angles,num_phases,num_samples);\n\n# array with off-resonance values\nΔf_arr_kHz = range(-1/TR_ms, 1/TR_ms, num_samples)\n\np2 = plot(title=\"Steady-State Signal Magnitude vs. Resonant Frequency\",\n    xlabel = \"Resonant Frequency (kHz)\",\n    ylabel = \"Signal Magnitude\",\n    titlefontsize=12,\n);\n\nfor i in 1:num_flip_angles # iterate over flip angles\n    α_deg = flip_ang_arr_deg[i]\n\n    for j in 1:num_phases # iterate over RF phases\n        ΔΦ_deg = ΔΦ_arr_deg[j]\n\n        for k in 1:num_samples # iterate over resonant frequencies\n            Δf_kHz = Δf_arr_kHz[k]\n\n            # convert off-resonance from kHz to Hz before input into function\n            local Δf_Hz = kHz_to_Hz(Δf_kHz)\n\n            # convert inputted RF phase cycling angle from degrees to radians\n            ΔΦ_rad = deg2rad(ΔΦ_deg)\n\n            # get tuple of values incorporating off-resonance and RF phase cycling for both compartments\n            Δf_tuple_Hz = get_Δf_tuple(ΔΦ_rad, Δf_Hz, Δf_myelin_Hz, TR_ms)\n            Δf_tuple_Hz_no_rf_phase_fact = get_Δf_tuple(0, Δf_Hz, Δf_myelin_Hz, TR_ms)\n\n            # create a spin (with and without RF phase-cycling factor)\n            spin_mc = SpinMC(mo, mwf_tuple, T1_ms_tuple, T2_ms_tuple, Δf_tuple_Hz, τ_tuple_ms)\n            spin_mc_no_rf_phase_fact = SpinMC(mo, mwf_tuple, T1_ms_tuple, T2_ms_tuple, Δf_tuple_Hz_no_rf_phase_fact, τ_tuple_ms)\n\n            # run the bSSFP blochsim and add to result array\n            signal = bssfp_blochsim_MC(α_deg, TR_ms, TE_ms, spin_mc, spin_mc_no_rf_phase_fact)\n            sig_arr[i,j,k] = abs(signal)\n        end\n\n        plot!(p2, Δf_arr_kHz, sig_arr[i,j,:];\n           label = \"α = $(α_deg)°, ΔΦ = $(ΔΦ_deg)°\")\n    end\nend\np2","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"prompt()","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"Recreate Figure 2 (magnitude plot) from [2] and also add the phase plot.","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"# Initialize the plot:\np_m = plot(title=\"Signal Magnitude vs. Scan Index\", ylabel = \"Signal Magnitude\")\np_p = plot(title=\"Signal Phase vs. Scan Index\", ylabel = \"Signal Phase\")\n\nnum_scans = 40 # number of different scans\nscan_idx = range(1,num_scans,num_scans)\n\nflip_ang_arr_deg = [10.0, 40.0] # flip angles for plot\nnum_flip_angles = length(flip_ang_arr_deg)\n\nΔf_Hz = 0.0 # set off-resonance to zero\n\ntau_arr_ms = [250, 150, 50] # array of exchange values\ntau_arr_marker = [:circle, :star5, :utriangle]\nnum_taus = length(tau_arr_ms)\n\nsig_arr = zeros(num_scans,num_taus) # arrays to store results\nsig_arr_phase = zeros(num_scans,num_taus)\n\nΔΦ_design_deg = ( # designed RF phase cycling increments\n [-176.4, -159.5, -142.1, -124.4, -107.6, -90.54, -73.62, -56.13, -39.41, -22.52, -5.272, 11.63, 28.93, 45.76, 63.08, 79.91, 96.97, 113.9, 131.3, 148.5, 166.1],\n [-168.8, -150.3, -130.1, -111.5, -93.19, -74.18, -54.68 , -37.15, -18.01, 1.342, 18.82, 38.64, 57.88, 76.48, 95.2, 113.3, 133.3, 153.1, 172.1],\n)\n\ncurr_scan = 1\n\nfor j in 1:num_taus # iterate over exchange values\n    local τ_fs = tau_arr_ms[j]\n    local τ_tuple_ms = get_τ_tuple(tau_arr_ms[j], f_f)\n    tau_marker = tau_arr_marker[j]\n\n    for k in 1:num_flip_angles # iterate over flip angles\n        α_deg = flip_ang_arr_deg[k]\n\n        # different RF phases for different flip angles - from Figure 1 in [2]\n        local ΔΦ_arr_deg = ΔΦ_design_deg[k]\n\n        for i in 1:length(ΔΦ_arr_deg) # iterate over RF phases\n            ΔΦ_deg = ΔΦ_arr_deg[i]\n\n            # convert RF phase cycling angle from degrees to radians\n            ΔΦ_rad = deg2rad(ΔΦ_deg)\n\n            # tuple of values incorporating off-resonance and RF phase cycling for both compartments\n            Δf_tuple_Hz = get_Δf_tuple(ΔΦ_rad, Δf_Hz, Δf_myelin_Hz, TR_ms)\n            Δf_tuple_Hz_no_rf_phase_fact = get_Δf_tuple(0, Δf_Hz, Δf_myelin_Hz, TR_ms)\n\n            # create a spin (with and without RF phase-cycling factor)\n            spin_mc = SpinMC(mo, mwf_tuple, T1_ms_tuple, T2_ms_tuple, Δf_tuple_Hz, τ_tuple_ms)\n            spin_mc_no_rf_phase_fact = SpinMC(mo, mwf_tuple, T1_ms_tuple, T2_ms_tuple, Δf_tuple_Hz_no_rf_phase_fact, τ_tuple_ms)\n\n            # run the bSSFP blochsim and add to result array\n            signal = bssfp_blochsim_MC(α_deg, TR_ms, TE_ms, spin_mc, spin_mc_no_rf_phase_fact)\n            sig_arr[curr_scan,j] = abs(signal)\n            sig_arr_phase[curr_scan,j] = angle(signal)\n\n            global curr_scan += 1\n        end\n    end\n\n    global curr_scan = 1\n\n    plot!(p_m, scan_idx,sig_arr[:,j], linewidth=0, markershape=tau_marker,\n        label = latexstring(\"\\$τ_{\\\\mathrm{fs}}\\$ = $τ_fs ms\"))\n    plot!(p_p, scan_idx,sig_arr_phase[:,j], linewidth=0, markershape=tau_marker,\n        label = latexstring(\"\\$τ_{\\\\mathrm{fs}}\\$ = $τ_fs ms\"))\nend\n\n# plot results and label axes\np3 = plot(p_m, p_p, layout = (2,1), xlabel = \"Scan Index\")","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"prompt()","category":"page"},{"location":"generated/examples/01-overview/#Reproducibility","page":"bSSFP","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"And with the following package versions","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"","category":"page"},{"location":"generated/examples/01-overview/","page":"bSSFP","title":"bSSFP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlochSim","category":"page"},{"location":"#BlochSim.jl-Documentation","page":"Home","title":"BlochSim.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package (BlochSim) provides functionality for simulating MRI pulse sequences.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the README and the \"Examples\" for details.","category":"page"}]
}
