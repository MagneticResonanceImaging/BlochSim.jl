<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>bSSFP · BlochSim.jl</title><meta name="title" content="bSSFP · BlochSim.jl"/><meta property="og:title" content="bSSFP · BlochSim.jl"/><meta property="twitter:title" content="bSSFP · BlochSim.jl"/><meta name="description" content="Documentation for BlochSim.jl."/><meta property="og:description" content="Documentation for BlochSim.jl."/><meta property="twitter:description" content="Documentation for BlochSim.jl."/><meta property="og:url" content="https://MagneticResonanceImaging.github.io/BlochSim.jl/stable/generated/examples/01-overview/"/><meta property="twitter:url" content="https://MagneticResonanceImaging.github.io/BlochSim.jl/stable/generated/examples/01-overview/"/><link rel="canonical" href="https://MagneticResonanceImaging.github.io/BlochSim.jl/stable/generated/examples/01-overview/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">BlochSim.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../methods/">Methods</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>bSSFP</a><ul class="internal"><li><a class="tocitem" href="#Method-1:-Use-matrices"><span>Method 1: Use matrices</span></a></li><li><a class="tocitem" href="#Recreate-Figure-3-from-[1]"><span>Recreate Figure 3 from [1]</span></a></li><li><a class="tocitem" href="#CRB-for-1-pool-bSSFP"><span>CRB for 1-pool bSSFP</span></a></li><li><a class="tocitem" href="#RF-pulse-duration"><span>RF pulse duration</span></a></li><li><a class="tocitem" href="#Multi-compartment-spins-and-myelin-water-exchange"><span>Multi-compartment spins and myelin water exchange</span></a></li><li><a class="tocitem" href="#Recreate-Figure-2-(magnitude-plot)-from-[2]"><span>Recreate Figure 2 (magnitude plot) from [2]</span></a></li><li><a class="tocitem" href="#Cramer-Rao-Bound"><span>Cramer-Rao Bound</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>bSSFP</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>bSSFP</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MagneticResonanceImaging/BlochSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/main/docs/lit/examples/01-overview.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="01-bssfp"><a class="docs-heading-anchor" href="#01-bssfp">bSSFP</a><a id="01-bssfp-1"></a><a class="docs-heading-anchor-permalink" href="#01-bssfp" title="Permalink"></a></h1><p>This page illustrates using the Julia package <a href="https://github.com/StevenWhitaker/BlochSim.jl"><code>BlochSim</code></a> to calculate MRI signals for balanced steady-state free precession <a href="https://en.wikipedia.org/wiki/Steady-state_free_precession_imaging">(bSSFP)</a> pulse sequences.</p><p>This demo facilitates understanding bSSFP sequences, multi-compartment spins, and myelin water exchange.</p><p>This demo recreates Figure 3 from [1] and Figure 2 from [2].</p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><ul><li><p>[1] Hargreaves, B., Vasanawala, S., Pauly, J., &amp; Nishimura, D. (2001). Characterization and reduction of the transient response in steady‐state MR imaging. <a href="https://doi.org/10.1002/mrm.1170">MRM 46(1), 149-158</a>.</p></li><li><p>[2] Murthy, N., Nielsen, J., Whitaker, S., Haskell, M., Swanson, S., Seiberlich, N., &amp; Fessler, J. (2022). Quantifying myelin water exchange using optimized bSSFP sequences. <a href="https://cds.ismrm.org/protected/22MProceedings/PDFfiles/2068.html">Proc. Intl. Soc. Mag. Res. Med (#2068)</a>.</p></li><li><p>[3] Hinshaw, W. S. (1976). Image formation by nuclear magnetic resonance: the sensitive‐point method. <a href="https://doi.org/10.1063/1.323136">J. of Applied Physics, 47(8), 3709-21</a>.</p></li><li><p>[4] Whitaker, S. T., Nataraj, G., Nielsen, J. F., &amp; Fessler, J. A. (2020). Myelin water fraction estimation using small‐tip fast recovery MRI. <a href="https://doi.org/10.1002/mrm.28259">MRM 84(4), 1977-90</a>.</p></li></ul><p>This page comes from a single Julia file: <a href="https://github.com/MagneticResonanceImaging/BlochSim.jl/blob/main/docs/lit/examples/01-overview.jl"><code>01-overview.jl</code></a>.</p><p>You can access the source code for such Julia documentation using the &#39;Edit on GitHub&#39; link in the top right. You can view the corresponding notebook in <a href="https://nbviewer.org/">nbviewer</a> here: <a href="https://nbviewer.org/github/MagneticResonanceImaging/BlochSim.jl/tree/gh-pages/dev/generated/examples/01-overview.ipynb"><code>01-overview.ipynb</code></a>, or open it in <a href="https://mybinder.org/">binder</a> here: <a href="https://mybinder.org/v2/gh/MagneticResonanceImaging/BlochSim.jl/gh-pages?filepath=dev/generated/examples/01-overview.ipynb"><code>01-overview.ipynb</code></a>.</p><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><p>First we add the Julia packages that are need for this demo. Change <code>false</code> to <code>true</code> in the following code block if you are using any of the following packages for the first time.</p><pre><code class="language-julia hljs">if false
    import Pkg
    Pkg.add([
        &quot;BlochSim&quot;
        &quot;ForwardDiff&quot;
        &quot;LaTeXStrings&quot;
        &quot;LinearAlgebra&quot;
        &quot;MIRTjim&quot;
        &quot;Plots&quot;
    ])
end</code></pre><p>Tell this Julia session to use the following packages for this example. Run <code>Pkg.add()</code> in the preceding code block first, if needed.</p><pre><code class="language-julia hljs">using BlochSim: Spin, SpinMC, InstantaneousRF, RF, excite, freeprecess
using BlochSim: bssfp, GAMMA
import ForwardDiff
using InteractiveUtils: versioninfo
using LaTeXStrings: latexstring
using LinearAlgebra: Diagonal, I, cond, diag, norm
using MIRTjim: prompt
using Plots: gui, plot, plot!, default
default(titlefontsize = 10, markerstrokecolor = :auto, label=&quot;&quot;, width = 1.5)</code></pre><p>The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.</p><pre><code class="language-julia hljs">isinteractive() || prompt(:draw);</code></pre><p>Define some useful helper functions.</p><pre><code class="language-julia hljs">Hz_to_kHz(Δf_Hz) = Δf_Hz * 10^(-3) # convert frequencies in Hz to kHz
kHz_to_Hz(Δf_kHz) = Δf_kHz * 10^(3); # convert frequencies in kHz to Hz</code></pre><p>The bSSFP pulse sequence in Figure 2 in [1] starts with a RF pulse, then</p><ul><li><code>a</code> is at time TE</li><li><code>b</code> is TR-TE later, right before next RF pulse</li><li><code>c</code> is immediately after the next RF pulse</li><li><code>d</code> is TE after that next RF pulse</li></ul><p>We use this to generate Figure 3 in [1] in two different ways. The RF excitation is repeated periodically and, in steady-state, the magnetization at point <em>a</em> is the same as at point <em>d</em>.</p><h2 id="Method-1:-Use-matrices"><a class="docs-heading-anchor" href="#Method-1:-Use-matrices">Method 1: Use matrices</a><a id="Method-1:-Use-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Method-1:-Use-matrices" title="Permalink"></a></h2><p>Use Equations 1 and 2 and Appendix A from [1]</p><p>Calculate the steady-state value at point <em>d</em> using the method from [1] using Equations 1 and 2 and Appendix A.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    bssfp_matrix(α_deg, TR_ms, TE_ms, Mz0, T1_ms, T2_ms, Δf_kHz=0)

Return steady-state magnetization signal value
at the echo time
for a bSSFP sequence
using method of
[Hargreaves et al., MRM 2001](https://doi.org/10.1002/mrm.1170).

# In
- `α_deg` flip angle of RF pulse (degrees)
- `TR_ms` repetition time (ms)
- `TE_ms` echo time (ms)
- `Mz0` initial condition for magnetization in the z-direction (constant)
- `T1_ms` MRI tissue parameter for T1 relaxation (ms)
- `T2_ms` MRI tissue parameter for T2 relaxation (ms)
- `Δf_Hz` off-resonance value (Hz) (default 0)

# Out
- `signal` steady-state magnetization (as a complex number)
&quot;&quot;&quot;
function bssfp_matrix(α_deg, TR_ms, TE_ms, Mz0, T1_ms, T2_ms, Δf_Hz=0)

    M0 = [0; 0; Mz0] # initial magnetization vector

    # rotation matrix for RF excitation about the x-axis
    α_rad = deg2rad(α_deg) # convert flip angle α from degrees to radians
    R = [1 0 0; 0 cos(α_rad) sin(α_rad); 0 -sin(α_rad) cos(α_rad)]

    # free precession matrix
    Pz(angle) = [cos(angle) sin(angle) 0 ; -sin(angle) cos(angle) 0 ; 0 0 1]
    P(τ_ms) = Pz( 2π * Hz_to_kHz(Δf_Hz) * τ_ms ) # angle in radians

    # matrices for T1 and T2 relaxation over a time τ
    C(E1, E2) = [E2 0 0; 0 E2 0; 0 0 E1]
    C(τ_ms) = C(exp(-τ_ms / T1_ms), exp(-τ_ms / T2_ms))
    D(τ_ms) = (I - C(τ_ms)) * [0 ; 0 ; Mz0]

    # matrices for various values of τ
    P1 = P(TE_ms)
    P2 = P(TR_ms - TE_ms)
    C1 = C(TE_ms)
    C2 = C(TR_ms - TE_ms)
    d1 = D(TE_ms)
    d2 = D(TR_ms - TE_ms)

    # matrix A and vector b for steady-state calculation
    A = P1 * C1 * R * P2 * C2
    b = P1 * C1 * R * d2 + d1

    Mss = (I - A) \ b # steady-state magnetization

    return complex(Mss[1], Mss[2]) # return the complex signal
end;</code></pre><h2 id="Recreate-Figure-3-from-[1]"><a class="docs-heading-anchor" href="#Recreate-Figure-3-from-[1]">Recreate Figure 3 from [1]</a><a id="Recreate-Figure-3-from-[1]-1"></a><a class="docs-heading-anchor-permalink" href="#Recreate-Figure-3-from-[1]" title="Permalink"></a></h2><p>And compare Method 1 above with Method 2 (using <code>bssfp</code> in <code>BlochSim</code>)</p><pre><code class="language-julia hljs">TR_ms, TE_ms = 10, 5 # scan parameters
Mz0, T1_ms, T2_ms = 1, 400, 100 # tissue parameters

num_off_res_values = 401 # vector of off-resonance values
Δf_arr_Hz = kHz_to_Hz(range(-1, 1, num_off_res_values) / TR_ms) # 2 periods

flip_ang_arr_deg = [15, 30, 60, 90]; # vector of flip angles</code></pre><p>Helper functions for broadcast:</p><pre><code class="language-julia hljs">bssfp_matrix(α_deg, Δf_Hz) =
    bssfp_matrix(α_deg, TR_ms, TE_ms, Mz0, T1_ms, T2_ms, Δf_Hz) # method 1
_bssfp(α_rad, Δf_Hz, Δϕ_rad) = bssfp(Mz0, T1_ms, T2_ms, Δf_Hz,
    TR_ms, TE_ms, Δϕ_rad, α_rad, -π/2) # method 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">_bssfp (generic function with 1 method)</code></pre><p>Call <code>bssfp_matrix</code> and <code>bssfp</code> for various flip angles and off-resonance values and verify that the calculations match.</p><pre><code class="language-julia hljs">sig_matrix = bssfp_matrix.(flip_ang_arr_deg&#39;, Δf_arr_Hz)
sig_blochsim = _bssfp.(deg2rad.(flip_ang_arr_deg)&#39;, Δf_arr_Hz, 0. #= Δϕ_rad =#)
@assert sig_matrix ≈ sig_blochsim # yes they match!</code></pre><p>Plot 1-pool signal magnitude and phase</p><pre><code class="language-julia hljs">label = reshape(map(a -&gt; &quot;α = $(a)°&quot;, flip_ang_arr_deg), 1, :) # row!
p_m = plot(Δf_arr_Hz, abs.(sig_blochsim); label,
    ylabel = &quot;Signal Magnitude&quot;)
p_p = plot(Δf_arr_Hz, angle.(sig_blochsim); label,
    xlabel = &quot;Resonant Frequency (Hz)&quot;,
    ylabel = &quot;Signal Phase&quot;)
pmp = plot(p_m, p_p, layout=(2,1), plot_title = &quot;bSSFP single pool&quot;,
    plot_titlefontsize = 13)</code></pre><img src="231244b6.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><p>Explore T1 dependence of bSSFP signal model</p><pre><code class="language-julia hljs">T1_ms_arr = range(0.90, 1.1, 3) * T1_ms
α_deg = 20
sig_t1 = bssfp.(Mz0, T1_ms_arr&#39;, T2_ms, Δf_arr_Hz,
    TR_ms, TE_ms, 0. #= Δϕ_rad =#, deg2rad(α_deg))

label = reshape(map(t -&gt; &quot;T1 = $t ms&quot;, T1_ms_arr), 1, :) # row!
pt1_m = plot(Δf_arr_Hz, abs.(sig_t1); label,
    ylabel = &quot;Signal Magnitude&quot;)
pt1_p = plot(Δf_arr_Hz, angle.(sig_t1); label,
    xlabel = &quot;Resonant Frequency (Hz)&quot;,
    ylabel = &quot;Signal Phase&quot;)
pt1 = plot(pt1_m, pt1_p, layout=(2,1), plot_title = &quot;bSSFP single pool for T1&quot;,
    plot_titlefontsize = 13)</code></pre><img src="166f5dbf.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><p>helper functions for CRB</p><pre><code class="language-julia hljs">real_imag(x) = [real(x); imag(x)] # stacker
snr2sigma(db::Real, yb::AbstractArray{&lt;:Complex}) =
    10^(-db/20) * norm(yb) / sqrt(length(yb));</code></pre><h2 id="CRB-for-1-pool-bSSFP"><a class="docs-heading-anchor" href="#CRB-for-1-pool-bSSFP">CRB for 1-pool bSSFP</a><a id="CRB-for-1-pool-bSSFP-1"></a><a class="docs-heading-anchor-permalink" href="#CRB-for-1-pool-bSSFP" title="Permalink"></a></h2><p>Using arbitrary flip angles and phase cycling increments as scan &quot;design&quot;</p><pre><code class="language-julia hljs">kappa = 1 # also estimate the B1+ factor
M0_phase = π/3 # just to make it non-trivial
x = [M0_phase, Mz0, T1_ms, T2_ms, kappa] # unknowns
Δf_Hz = -7 # known

Δϕ_rad = (0:7)/8 * 2π
α_rad = [π/7, π/3]
tmp = Iterators.product(Δϕ_rad, α_rad)
design = (
  Δϕ_rad = vec(map(x-&gt;x[1], tmp)),
  α_rad = vec(map(x-&gt;x[2], tmp)),
)

signal_c = (x) -&gt; cis(x[1] #= M0_phase =#) *
    bssfp.(x[2:end-1]..., Δf_Hz,
        TR_ms, TE_ms, design.Δϕ_rad, design.α_rad * x[end] #= kappa =#)
signal_ri(x) = real_imag(signal_c(x))


dB = 40 # SNR
σ = snr2sigma(dB, signal_c(x)) # noise level</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0020524873360052783</code></pre><p>Jacobian</p><pre><code class="language-julia hljs">jac = ForwardDiff.jacobian(signal_ri, x)
fish = jac&#39; * jac / σ^2
cond(fish) # 9e8</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8.699456796516544e8</code></pre><p>CRB and standard deviation:</p><pre><code class="language-julia hljs">crb = inv(fish)
crb_std = sqrt.(diag(crb))
cov1 = round.(crb_std ./ x ; digits=3) # coefficient of variation</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 0.002
 0.089
 0.183
 0.027
 0.083</code></pre><h2 id="RF-pulse-duration"><a class="docs-heading-anchor" href="#RF-pulse-duration">RF pulse duration</a><a id="RF-pulse-duration-1"></a><a class="docs-heading-anchor-permalink" href="#RF-pulse-duration" title="Permalink"></a></h2><p>The preceding calculations were all for hypothetical instantaneous&quot; RF pulses.</p><p>Examine effects of finite RF pulse duration for a spin with a relatively short T2.</p><pre><code class="language-julia hljs">Mz0, T1_ms, T2_ms, Δf_Hz = 1, 400, 40, 0 # tissue parameters
TR_ms, TE_ms, α_rad = 8, 4, deg2rad(50) # scan parameters

Δϕ_rad = range(-1,1,101) * π
rf0 = InstantaneousRF(α_rad)
_bssfp(Δϕ_rad, rf) = bssfp(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, rf);</code></pre><p>Specify finite-duration hard (rectangular) RF pulse</p><ul><li><code>GAMMA</code> has units rad/s/G</li><li>Tip angle for constant pulse: <code>α_rad = GAMMA * b1_gauss * tRF_s</code></li><li>so <code>b1_gauss = α_rad / GAMMA / tRF_s</code></li></ul><pre><code class="language-julia hljs">tRF_ms = 1
waveform1 = [1] * α_rad / (tRF_ms / 1000) / GAMMA # single sample i.e. instant!
rf1 = RF(waveform1, tRF_ms)
signal0 = map(Δϕ -&gt; _bssfp(Δϕ, rf0), Δϕ_rad)
signal1 = map(Δϕ -&gt; _bssfp(Δϕ, rf1), Δϕ_rad)
@assert signal0 ≈ signal1
@assert α_rad == rf0.α ≈ only(rf1.α)</code></pre><p>Plot</p><pre><code class="language-julia hljs">prfm = plot(
 xlabel = &quot;phase cycling increment Δϕ (rad)&quot;,
 ylabel = &quot;bSSFP signal mag&quot;,
)
prfa = plot(
 xlabel = &quot;phase cycling increment Δϕ (rad)&quot;,
 ylabel = &quot;bSSFP signal phase&quot;,
)
plot!(prfm, Δϕ_rad, abs.(signal0), label=&quot;Instantaneous&quot;)
plot!(prfa, Δϕ_rad, angle.(signal0), label=&quot;Instantaneous&quot;)
nw = 1000 # approximately 1μs dwell time
for tRF_ms in [1e-2 1 2]
    waveform2 = ones(nw) * α_rad / (tRF_ms / 1000) / GAMMA
    rf2 = RF(waveform2, tRF_ms/nw)
    @assert rf0.α ≈ sum(rf2.α)
    signal2 = map(Δϕ -&gt; _bssfp(Δϕ, rf2), Δϕ_rad)
    label = &quot;tRF = $tRF_ms ms, nw=$nw&quot;
    plot!(prfm, Δϕ_rad, abs.(signal2); label)
    plot!(prfa, Δϕ_rad, angle.(signal2); label)
end;

prf = plot(prfm, prfa, layout=(2,1),
 plot_title=&quot;RF pulse duration effect, T2=$T2_ms (ms)&quot;)</code></pre><img src="dc643117.svg" alt="Example block output"/><h2 id="Multi-compartment-spins-and-myelin-water-exchange"><a class="docs-heading-anchor" href="#Multi-compartment-spins-and-myelin-water-exchange">Multi-compartment spins and myelin water exchange</a><a id="Multi-compartment-spins-and-myelin-water-exchange-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-compartment-spins-and-myelin-water-exchange" title="Permalink"></a></h2><p>Generate Figure 2 from [2] using <code>BlochSim</code>. First define some useful helper functions. These functions put the parameters in the correct format for the multi-compartment spin object constructors.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
- in: `f_f` fast fraction (myelin fraction)
- out: `mwf_tuple` tuple with fast and slow fractions
&quot;&quot;&quot;
get_mwf_tuple(f_f) = (f_f, 1-f_f)


&quot;&quot;&quot;
    get_τ_tuple(τ_fs_ms, f_f)
# In:
- `τ_fs_ms` residence time for exchange from myelin to non-myelin water (ms)
- `f_f` fast fraction (myelin fraction)
# Out:
- `τ_tuple_ms` tuple with fast-to-slow and slow-to-fast residence times
&quot;&quot;&quot;
function get_τ_tuple(τ_fs_ms, f_f)
    τ_sf_ms = (1-f_f) * τ_fs_ms / f_f
    return (τ_fs_ms, τ_sf_ms)
end


&quot;&quot;&quot;
# In:
- `Δϕ_rad` RF phase cycling value (radians)
- `Δf0_Hz` off-resonance value (Hz)
- `Δf_myelin_Hz` # additional off-resonance value only experienced by myelin water (Hz)
- `TR_ms` repetition time (ms)
# Out:
- `Δf_tuple_Hz` tuple with off-resonance values for fast and slow compartments

[Hinshaw, J. Appl. Phys. 1976](https://doi.org/10.1063/1.323136).
&quot;&quot;&quot;
function get_Δf_tuple(Δϕ_rad, Δf0_Hz, Δf_myelin_Hz, TR_ms)

    # convert the RF phase cycling value to Hz from radians
    Δϕ_Hz = kHz_to_Hz((Δϕ_rad) / (2π*TR_ms))

    # subtract the RF phase cycling value from the off-resonance value
    Δf_RF_Hz = Δf0_Hz - Δϕ_Hz

    # add the myelin off-resonance for the myelin term
    Δf_myelin_RF_Hz = Δf_RF_Hz + Δf_myelin_Hz

    # create and return tuple for the spin object constructor
    Δf_tuple_Hz = (Δf_myelin_RF_Hz, Δf_RF_Hz)
    return Δf_tuple_Hz
end;</code></pre><p>Define a function similar to Method 2 above, but for multi-compartment spin objects.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    bssfp2(α_deg, TR_ms, TE_ms, spin, spin_no_rf_phase_fact)

Return steady-state magnetization signal value
at the echo time
for a phase-cycled bSSFP sequence
using BlochSim.

Ref: Murthy, N., Nielsen, J. F., Whitaker, S. T., Haskell, M. W.,
Swanson, S. D., Seiberlich, N., &amp; Fessler, J. A. (2022).
Quantifying myelin water exchange using optimized bSSFP
sequences. In Proc. Intl. Soc. Mag. Res. Med (p. 2068). [2]

# In
- `α_deg` flip angle of RF pulse (degrees)
- `TR_ms` repetition time (ms)
- `TE_ms` echo time (ms)
- &#39;spin&#39; multi-compartment spin object with RF phase cycling factor
- &#39;spin_no_rf_phase_fact&#39; multi-compartment spin object without RF phase cycling factor

# Out
- `signal` steady-state magnetization (as a complex number)
&quot;&quot;&quot;
function bssfp2(
    α_deg::Number, TR_ms::Number, TE_ms::Number,
    spin::SpinMC, spin_no_rf_phase_fact::SpinMC,
)

    # convert flip angle α from degrees to radians
    α_rad = deg2rad(α_deg)

    # excite the spin and reshape R to be the correct dimensions for a SpinMC object
    (R,) = excite(spin, InstantaneousRF(α_rad))
    R = Matrix(R.A)
    R = kron(I(2),R)

    # precession/relaxation of the spin for TR
    (PC_TR_A, PC_TR_B) = freeprecess(spin, TR_ms)

    # precession/relaxation of the spin for TE
    # assume receiver modulates signal and uses the receiver phase as the RF phase
    (PC_TE_A, PE_TE_B) = freeprecess(spin_no_rf_phase_fact, TE_ms)

    # calculate A matrix and b vector
    A = Matrix(PC_TR_A) * R
    b = Vector(PC_TR_B)

    Mss = (I - A) \ b # steady-state just before tip down
    M = R * Mss # magnetization after tip-down

    # steady-state magnetization at the echo time
    M = Matrix(PC_TE_A) * M + Vector(PE_TE_B)

    return complex(M[1]+M[4], M[2]+M[5]) # return the complex signal
end;</code></pre><p>Intermediate helper</p><pre><code class="language-julia hljs">function bssfp2(
    Mz0::Number,
    frac::NTuple{2, Number},
    T1_ms::NTuple{2, Number},
    T2_ms::NTuple{2, Number},
    Δf_Hz::NTuple{2, Number},
    Δf_no_rf_phase_Hz::NTuple{2, Number},
    τ_ms::NTuple{2, Number},
    α_deg::Number, TR_ms::Number, TE_ms::Number,
)

    # create spin (with and without RF phase-cycling factor)
    spin = SpinMC(Mz0, frac, T1_ms, T2_ms, Δf_Hz, τ_ms)
global spin1 = spin
    spin_no_rf_phase = SpinMC(Mz0, frac, T1_ms, T2_ms, Δf_no_rf_phase_Hz, τ_ms)

    return bssfp2(α_deg, TR_ms, TE_ms, spin, spin_no_rf_phase)
end;


&quot;&quot;&quot;
    bssfp2(...)
Version with scalar arguments (convenient for autodiff)
&quot;&quot;&quot;
function bssfp2(
    M0_phase::Number, # radians
    Mz0::Number,
    f_f::Number,
    T1_f_ms::Number,
    T1_s_ms::Number,
    T2_f_ms::Number,
    T2_s_ms::Number,
    τ_fs_ms::Number,
    Δff_Hz::Number, # fast component frequency shift
    # system parameter (sometimes known):
    Δf0_Hz::Number, # B0 off resonance
    # scan parameters (always known):
    α_deg::Number, TR_ms::Number, TE_ms::Number,
    Δϕ_deg::Number, # RF phase cycling value (degrees)
)

    τ_tuple_ms = get_τ_tuple(τ_fs_ms, f_f) # fast-to-slow and slow-to-fast residence times

    # tuple of values incorporating off-resonance and RF phase cycling for both compartments
    Δϕ_rad = deg2rad(Δϕ_deg)
    Δf_tuple_Hz = get_Δf_tuple(Δϕ_rad, Δf0_Hz, Δff_Hz, TR_ms)
    Δf_tuple_Hz_no_rf_phase = get_Δf_tuple(0, Δf0_Hz, Δff_Hz, TR_ms)

    return cis(M0_phase) * bssfp2(
     Mz0,
     (f_f, 1 - f_f),
     (T1_f_ms, T1_s_ms),
     (T2_f_ms, T2_s_ms),
     Δf_tuple_Hz,
     Δf_tuple_Hz_no_rf_phase,
     τ_tuple_ms,
     α_deg, TR_ms, TE_ms,
    )
end;</code></pre><p>Define variables to be used in the following plots. Values taken from [2] and [4].</p><pre><code class="language-julia hljs">Mz0 = 0.77 # initial condition for longitudinal magnetization (constant)
Δf_myelin_Hz = 5.0 # frequency shift of myelin water
f_f = 0.15; # myelin water fraction (MWF), fast fraction

# T1 and T2 values
T1_f_ms = 400 # T1 for fast-relaxing, myelin water compartment
T1_s_ms = 832 # T1 for slow-relaxing, non-myelin water compartment

T2_f_ms = 20 # T2 for fast-relaxing, myelin water compartment
T2_s_ms = 80 # T2 for slow-relaxing, non-myelin water compartment

TR_ms, TE_ms = 20, 4; # scan parameters (note: TE = TR/2 would be more logical)</code></pre><p>Generate plots similar to Figure 3 from [1] but with three different RF phase cycling factor values: (0, 90, and 180 degrees).</p><p>For this example, choose one exchange rate:</p><pre><code class="language-julia hljs">τ_fs = 50.0 # this will be varied in the next plot

flip_ang_arr_deg = [10, 40] # flip angles

Δϕ_arr_deg = [0, 90, 180] # RF phase cycling value (degrees)

# vector of off-resonance values
num_samples = 401 # number of samples (resonant frequencies)
Δf_arr_Hz = kHz_to_Hz(range(-1, 1, num_samples) / TR_ms);</code></pre><p>Broadcast via <code>map</code> using helper functions</p><pre><code class="language-julia hljs">bssfp_mc(Δf0_Hz::Number, Δϕ_deg::Number, α_deg::Number, τ_fs::Number) =
    bssfp2(0 #= phase =#, Mz0, f_f, T1_f_ms, T1_s_ms, T2_f_ms, T2_s_ms, τ_fs,
        Δf_myelin_Hz, Δf0_Hz, α_deg, TR_ms, TE_ms, Δϕ_deg)

tmp = Iterators.product(Δf_arr_Hz, Δϕ_arr_deg, flip_ang_arr_deg)
bssfp_mc(t3::NTuple{3, Any}) = bssfp_mc(t3..., τ_fs) # (Δf_Hz, Δϕ_deg, α_deg)
signal_mc = map(bssfp_mc, tmp);</code></pre><p>Plot 2-pool signals</p><pre><code class="language-julia hljs">pmcm = plot(ylabel = &quot;Signal Magnitude&quot;)
pmcp = plot( ylabel = &quot;Signal Phase&quot;, xlabel = &quot;Resonant Frequency (Hz)&quot;)
for i in 1:size(signal_mc,3), j in 1:size(signal_mc,2)
    label2 = &quot;α = $(flip_ang_arr_deg[i])°, Δϕ = $(Δϕ_arr_deg[j])°&quot;
    tmp2 = signal_mc[:,j,i]
    plot!(pmcm, Δf_arr_Hz, abs.(tmp2))
    plot!(pmcp, Δf_arr_Hz, angle.(tmp2); label = label2)
end

p2 = plot(pmcm, pmcp, layout = (2,1), titlefontsize = 12,
    plot_title = &quot;bSSFP 2-pool magnitude and phase&quot;)</code></pre><img src="3f4065a2.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><h2 id="Recreate-Figure-2-(magnitude-plot)-from-[2]"><a class="docs-heading-anchor" href="#Recreate-Figure-2-(magnitude-plot)-from-[2]">Recreate Figure 2 (magnitude plot) from [2]</a><a id="Recreate-Figure-2-(magnitude-plot)-from-[2]-1"></a><a class="docs-heading-anchor-permalink" href="#Recreate-Figure-2-(magnitude-plot)-from-[2]" title="Permalink"></a></h2><p>and also plot the phase.</p><pre><code class="language-julia hljs">Δf_Hz = 0.0 # set off-resonance to zero for this plot
tau_arr_ms = [250, 150, 50] # array of exchange values
tau_arr_marker = [:circle, :star5, :utriangle]

Δϕ_design_deg = ( # designed RF phase cycling increments
 [-176.4, -159.5, -142.1, -124.4, -107.6, -90.54, -73.62, -56.13, -39.41, -22.52, -5.272, 11.63, 28.93, 45.76, 63.08, 79.91, 96.97, 113.9, 131.3, 148.5, 166.1],
 [-168.8, -150.3, -130.1, -111.5, -93.19, -74.18, -54.68 , -37.15, -18.01, 1.342, 18.82, 38.64, 57.88, 76.48, 95.2, 113.3, 133.3, 153.1, 172.1],
)

α_arr_deg = [10.0, 40.0] # flip angles for plot
α_design_deg = [
  fill(α_arr_deg[1], length(Δϕ_design_deg[1]));
  fill(α_arr_deg[2], length(Δϕ_design_deg[2]))
]
design = (Δϕ_deg = vcat(Δϕ_design_deg...), α_deg = α_design_deg)
num_scans = length(design.Δϕ_deg) # number of different scans = 40

tmp = (τ_fs) -&gt; (Δϕ_deg, α_deg) -&gt; bssfp_mc(Δf_Hz, Δϕ_deg, α_deg, τ_fs)
bssfp_signal(τ_fs) = map(splat(tmp(τ_fs)), zip(design...))

signal = bssfp_signal.(tau_arr_ms)

# Plot
scan_idx = 1:num_scans
p_m = plot(title=&quot;Signal Magnitude vs. Scan Index&quot;, ylabel = &quot;Signal Magnitude&quot;)
p_p = plot(title=&quot;Signal Phase vs. Scan Index&quot;, ylabel = &quot;Signal Phase&quot;)
for j = 1:length(signal) # iterate over exchange values
    markershape = tau_arr_marker[j]
    local label = latexstring(&quot;\$τ_{\\mathrm{fs}}\$ = $τ_fs ms&quot;)
    plot!(p_m, scan_idx, abs.(signal[j]), linewidth=0; markershape, label)
    plot!(p_p, scan_idx, angle.(signal[j]), linewidth=0; markershape, label)
end
p3 = plot(p_m, p_p, layout = (2,1), xlabel = &quot;Scan Index&quot;)</code></pre><img src="d6a04a33.svg" alt="Example block output"/><pre><code class="language-julia hljs">prompt()</code></pre><h2 id="Cramer-Rao-Bound"><a class="docs-heading-anchor" href="#Cramer-Rao-Bound">Cramer-Rao Bound</a><a id="Cramer-Rao-Bound-1"></a><a class="docs-heading-anchor-permalink" href="#Cramer-Rao-Bound" title="Permalink"></a></h2><p>for the designed scan</p><pre><code class="language-julia hljs">kappa = 1 # also estimate the B1+ factor
M0_phase = π/3 # just to make it non-trivial
x = [M0_phase, Mz0, f_f, T1_f_ms, T1_s_ms, T2_f_ms, T2_s_ms, τ_fs, Δf_myelin_Hz, kappa] # unknowns
signal_c = (x) -&gt; bssfp.(x[1:end-1]..., Δf_Hz, x[end]*design.α_deg, TR_ms, TE_ms, design.Δϕ_deg)
signal_ri(x) = real_imag(signal_c(x));</code></pre><p>Noise level</p><pre><code class="language-julia hljs">dB = 40 # SNR
σ = snr2sigma(dB, signal_c(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0007603283140175785</code></pre><p>Jacobian</p><pre><code class="language-julia hljs">jac = ForwardDiff.jacobian(signal_ri, x)
fish = jac&#39; * jac / σ^2
cond(fish) # 5e10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.5690320949390195e13</code></pre><p>The condition number depends on units, so remove units:</p><pre><code class="language-julia hljs">D = Diagonal(1 ./ sqrt.(diag(fish)))
tmp = D * fish * D
cond(tmp) # 1e6</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.399349155030611e6</code></pre><p>CRB and standard deviation:</p><pre><code class="language-julia hljs">crb = inv(fish)
crb_std = sqrt.(diag(crb))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Float64}:
   0.012787381115187886
   0.02846454182481993
   0.2935984966128955
 341.6818669142746
 741.3419163389099
  17.583009839925374
  75.60122313607312
 115.1909452787234
   8.592029636589865
   0.0027929613975509575</code></pre><p>Coefficient of variation</p><pre><code class="language-julia hljs">round.(crb_std ./ x ; digits=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Float64}:
 0.01
 0.04
 1.96
 0.85
 0.89
 0.88
 0.95
 2.3
 1.72
 0.0</code></pre><h3 id="Reproducibility"><a class="docs-heading-anchor" href="#Reproducibility">Reproducibility</a><a id="Reproducibility-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducibility" title="Permalink"></a></h3><p>This page was generated with the following version of Julia:</p><pre><code class="language-julia hljs">using InteractiveUtils: versioninfo
io = IOBuffer(); versioninfo(io); split(String(take!(io)), &#39;\n&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12-element Vector{SubString{String}}:
 &quot;Julia Version 1.12.4&quot;
 &quot;Commit 01a2eadb047 (2026-01-06 16:56 UTC)&quot;
 &quot;Build Info:&quot;
 &quot;  Official https://julialang.org release&quot;
 &quot;Platform Info:&quot;
 &quot;  OS: Linux (x86_64-linux-gnu)&quot;
 &quot;  CPU: 4 × AMD EPYC 7763 64-Core Processor&quot;
 &quot;  WORD_SIZE: 64&quot;
 &quot;  LLVM: libLLVM-18.1.7 (ORCJIT, znver3)&quot;
 &quot;  GC: Built with stock GC&quot;
 &quot;Threads: 1 default, 1 interactive, 1 GC (on 4 virtual cores)&quot;
 &quot;&quot;</code></pre><p>And with the following package versions</p><pre><code class="language-julia hljs">import Pkg; Pkg.status()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Status `~/work/BlochSim.jl/BlochSim.jl/docs/Project.toml`
  [6e4b80f9] BenchmarkTools v1.6.3
  [5c0f8cbe] BlochSim v0.8.0 `~/work/BlochSim.jl/BlochSim.jl`
  [e30172f5] Documenter v1.16.1
  [f6369f11] ForwardDiff v1.3.2
  [b964fa9f] LaTeXStrings v1.4.0
  [98b081ad] Literate v2.21.0
  [170b2178] MIRTjim v0.26.0
  [91a5bcdd] Plots v1.41.5
  [1986cc42] Unitful v1.28.0
  [b77e0a4c] InteractiveUtils v1.11.0
  [37e2e46d] LinearAlgebra v1.12.0
  [44cfe95a] Pkg v1.12.1
  [9a3f8284] Random v1.11.0</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../methods/">« Methods</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 5 February 2026 13:51">Thursday 5 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
