var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#BlochSim.GAMBAR","page":"Methods","title":"BlochSim.GAMBAR","text":"GAMBAR\n\nGyromagnetic ratio for ¹H with units Hz/G.\n\n\n\n\n\n","category":"constant"},{"location":"methods/#BlochSim.GAMMA","page":"Methods","title":"BlochSim.GAMMA","text":"GAMMA\n\nGyromagnetic ratio for ¹H with units rad/s/G.\n\n\n\n\n\n","category":"constant"},{"location":"methods/#BlochSim.AbstractRF","page":"Methods","title":"BlochSim.AbstractRF","text":"AbstractRF\n\nAbstract type for representing radiofrequency (RF) pulses.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.AbstractSpin","page":"Methods","title":"BlochSim.AbstractSpin","text":"AbstractSpin\n\nAbstract type for representing individual spins.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.AbstractSpoiling","page":"Methods","title":"BlochSim.AbstractSpoiling","text":"AbstractSpoiling\n\nAbstract type for representing spoiling.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochDynamicsMatrix","page":"Methods","title":"BlochSim.BlochDynamicsMatrix","text":"BlochDynamicsMatrix(R1, R2, Δω)\nBlochDynamicsMatrix{T}()\nBlochDynamicsMatrix()\n\nCreate a mutable BlochDynamicsMatrix object.\n\nProperties\n\nR1::Real: Spin-lattice relaxation rate\nR2::Real: Spin-spin relaxation rate\nΔω::Real: Off-resonance frequency\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochMatrix","page":"Methods","title":"BlochSim.BlochMatrix","text":"BlochMatrix(a11, a21, a31, a12, a22, a32, a13, a23, a33)\nBlochMatrix{T}()\nBlochMatrix()\n\nCreate a mutable BlochMatrix object representing a fixed-size 3×3 matrix.\n\nProperties\n\naij::Real: Matrix entry (i,j) ∈ {1, 2, 3}²\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochMcConnellDynamicsMatrix","page":"Methods","title":"BlochSim.BlochMcConnellDynamicsMatrix","text":"BlochMcConnellDynamicsMatrix(A, E)\nBlochMcConnellDynamicsMatrix{T}(N)\nBlochMcConnellDynamicsMatrix(N)\n\nCreate a BlochMcConnellDynamicsMatrix object with N compartments.\n\nProperties\n\nA::NTuple{N,BlochDynamicsMatrix{<:Real}}: List of BlochDynamicsMatrixes that make up the main block diagonal of the BlochMcConnellDynamicsMatrix\nE::NTuple{M,ExchangeDynamicsMatrix{<:Real}}: List of ExchangeDynamicsMatrixes that describe exchange between the different compartments; these matrices make up the remaining M = N^2 - N blocks of the BlochMcConnellDynamicsMatrix, sorted by column-major ordering\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.BlochMcConnellMatrix","page":"Methods","title":"BlochSim.BlochMcConnellMatrix","text":"BlochMcConnellMatrix(A)\nBlochMcConnellMatrix{T}(N)\nBlochMcConnellMatrix(N)\n\nCreate a BlochMcConnellMatrix object with N compartments and representing a fixed-size 3N×3N matrix.\n\nProperties\n\nA::NTuple{N,NTuple{N,BlochMatrix{<:Real}}}: List of 3×3 matrices that comprise the blocks of the BlochMcConnellMatrix; A[i][j] is the (i,j)th block\n\nExamples\n\njulia> B = BlochMcConnellMatrix(3)\nBlochMcConnellMatrix{Float64,3}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> fill!(B, 0.5)\n\njulia> B\nBlochMcConnellMatrix{Float64,3}:\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n 0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5  0.5\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.ExchangeDynamicsMatrix","page":"Methods","title":"BlochSim.ExchangeDynamicsMatrix","text":"ExchangeDynamicsMatrix(r)\nExchangeDynamicsMatrix{T}()\nExchangeDynamicsMatrix()\n\nCreate a mutable ExchangeDynamicsMatrix object.\n\nProperties\n\nr::Real: Exchange rate from one compartment to another\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.ExcitationMatrix","page":"Methods","title":"BlochSim.ExcitationMatrix","text":"ExcitationMatrix(A)\nExcitationMatrix{T}()\nExcitationMatrix()\n\nCreate an ExcitationMatrix object. Multiplying by a MagnetizationMC object has the effect of multiplying each component of the multi-compartment magnetization by the ExcitationMatrix.\n\nProperties\n\nA::BlochMatrix{<:Real}: Matrix used to describe the excitation\n\nExamples\n\njulia> E = ExcitationMatrix(BlochMatrix(0, 1, 0, 1, 0, 0, 0, 0, 1))\nExcitationMatrix{Int64}:\n 0  1  0\n 1  0  0\n 0  0  1\n\njulia> M = MagnetizationMC((1, 2, 3), (4, 5, 6))\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 1\n  My = 2\n  Mz = 3\n Compartment 2:\n  Mx = 4\n  My = 5\n  Mz = 6\n\njulia> E * M\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 2\n  My = 1\n  Mz = 3\n Compartment 2:\n  Mx = 5\n  My = 4\n  Mz = 6\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.FreePrecessionMatrix","page":"Methods","title":"BlochSim.FreePrecessionMatrix","text":"FreePrecessionMatrix(E1, E2, θ)\nFreePrecessionMatrix{T}()\nFreePrecessionMatrix()\n\nCreate a mutable FreePrecessionMatrix object encoding the effects of relaxation and off-resonance precession.\n\nProperties\n\nE1::Real: T1 relaxation\nE2::Real: T2 relaxation\nθ::Real: Angle of off-resonance precession (rad)\n\nExamples\n\njulia> T1 = 1000; T2 = 100; Δω = π/600; t = 100;\n\njulia> F = FreePrecessionMatrix(exp(-t / T1), exp(-t / T2) * cos(Δω * t), exp(-t / T2) * sin(Δω * t))\nFreePrecessionMatrix{Float64}:\n E1 = 0.9048374180359595\n E2 = 0.31859294158449203\n θ = 0.18393972058572114 rad\n\njulia> Matrix(F)\n3×3 Matrix{Float64}:\n  0.313219  0.058272  0.0\n -0.058272  0.313219  0.0\n  0.0       0.0       0.904837\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Gradient","page":"Methods","title":"BlochSim.Gradient","text":"Gradient(x, y, z)\n\nCreate a Gradient object representing x, y, and z B0 gradients. Units are G/cm.\n\nProperties\n\nx::Real: x gradient\ny::Real: y gradient\nz::Real: z gradient\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.GradientSpoiling","page":"Methods","title":"BlochSim.GradientSpoiling","text":"GradientSpoiling(grad, Tg) <: AbstractSpoiling\nGradientSpoiling(gx, gy, gz, Tg)\n\nRepresents gradient spoiling, e.g., applying a gradient grad = Gradient(gx, gy, gz) for time Tg (ms). grad can be a Gradient (or gx, gy, and gz can be scalars), representing a constant gradient, or grad can be a collection of Gradients (or gx, gy, and gz can be collections of values), representing a gradient waveform with a constant time step.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.IdealSpoiling","page":"Methods","title":"BlochSim.IdealSpoiling","text":"IdealSpoiling() <: AbstractSpoiling\n\nRepresents ideal spoiling, i.e., setting the transverse (x and y) components of a spin's magnetization to 0.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.IdealSpoilingMatrix","page":"Methods","title":"BlochSim.IdealSpoilingMatrix","text":"idealspoiling = IdealSpoilingMatrix()\n\nMatrix representing ideal spoiling. Multiplying by a Magnetization or MagnetizationMC has the effect of setting the x and y components to 0.\n\nExamples\n\njulia> idealspoiling * MagnetizationMC((1, 1, 1), (2, 2, 2))\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 0\n  My = 0\n  Mz = 1\n Compartment 2:\n  Mx = 0\n  My = 0\n  Mz = 2\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.InstantaneousRF","page":"Methods","title":"BlochSim.InstantaneousRF","text":"InstantaneousRF(α, θ = 0) <: AbstractRF\n\nRepresents an idealized instantaneous RF pulse with flip angle α and phase θ.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.MESEBlochSim","page":"Methods","title":"BlochSim.MESEBlochSim","text":"mese! = MESEBlochSim(TR, TE, nechoes, [rfex, rfref, rephaser, crusher, spoiling])\nmese!(spin, [workspace])\n\nSimulate a multi-echo spin echo (MESE) scan on spin, overwriting the spin's magnetization vector. Returns a Vector with the magnetization vectors at each echo.\n\nArguments\n\nTR::Real: Repetition time (ms)\nTE::Real: First echo time, and echo spacing (ms); the first echo time is measured from the middle of the excitation pulse\nnechoes::Integer: Number of echoes to readout\nrfex::AbstractRF = InstantaneousRF(π/2): Excitation RF pulse\nrfref::AbstractRF = InstantaneousRF(π, -π/2): Refocussing RF pulse\nrephaser::Union{<:GradientSpoiling,Nothing} = nothing: Slice-select excitation rephasing gradient\ncrusher::Union{<:GradientSpoiling,Nothing} = nothing: Crusher gradient (placed on either side of each refocussing pulse)\nspoiling::Union{IdealSpoiling,<:GradientSpoiling,Nothing} = IdealSpoiling(): Type of spoiling to apply\n\nworkspace isa MESEBlochSimWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Magnetization","page":"Methods","title":"BlochSim.Magnetization","text":"Magnetization(x, y, z)\nMagnetization{T}()\nMagnetization()\n\nCreate a mutable Magnetization object representing a 3D magnetization vector.\n\nProperties\n\nx::Real: x component of magnetization vector\ny::Real: y component of magnetization vector\nz::Real: z component of magnetization vector\n\nExamples\n\njulia> M = Magnetization()\nMagnetization vector with eltype Float64:\n Mx = 0.0\n My = 0.0\n Mz = 0.0\n\njulia> M.x = 1; M.y = 2; M.z = 3; M\nMagnetization vector with eltype Float64:\n Mx = 1.0\n My = 2.0\n Mz = 3.0\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.MagnetizationMC","page":"Methods","title":"BlochSim.MagnetizationMC","text":"MagnetizationMC((x1, y1, z1), ...)\nMagnetizationMC{T}(N)\nMagnetizationMC(N)\n\nCreate a MagnetizationMC object representing N 3D magnetization vectors in the same physical location.\n\nOne can access the ith component magnetization vector by indexing the MagnetizationMC object. Furthermore, iterating the MagnetizationMC object iterates through each of the component magnetization vectors.\n\nProperties\n\nM::NTuple{N,Magnetization{<:Real}}: List of component magnetization vectors\n\nExamples\n\njulia> M = MagnetizationMC((1, 2, 3), (4, 5, 6))\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 1\n  My = 2\n  Mz = 3\n Compartment 2:\n  Mx = 4\n  My = 5\n  Mz = 6\n\njulia> M[2]\nMagnetization vector with eltype Int64:\n Mx = 4\n My = 5\n Mz = 6\n\njulia> foreach(m -> (m.x = 0; m.y = 1; m.z = 2), M)\n\njulia> M\n2-compartment Magnetization vector with eltype Int64:\n Compartment 1:\n  Mx = 0\n  My = 1\n  Mz = 2\n Compartment 2:\n  Mx = 0\n  My = 1\n  Mz = 2\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Position","page":"Methods","title":"BlochSim.Position","text":"Position(x, y, z)\n\nCreate a mutable Position object representing a 3D location. Units are cm.\n\nProperties\n\nx::Real: x position\ny::Real: y position\nz::Real: z position\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.RF","page":"Methods","title":"BlochSim.RF","text":"RF(waveform, Δt, [Δθ], [grad]) <: AbstractRF\n\nRepresent an RF pulse with the given (possibly complex-valued) waveform (G) and time step Δt (ms).\n\nOptions\n\nΔθ additional phase added to the waveform (defaults to 0 radians)\ngrad B0 gradient that is turned on during the RF pulse (defaults to Gradient(0, 0, 0), i.e., turned off).\n\nProperties\n\nα::Vector{<:Real}: Instantaneous flip angles (rad) at each time point; computed from the magnitude of waveform\nθ::Vector{<:Real}: Instantaneous phase (rad) at each time point; computed from the phase of waveform\nΔt::Real: Time step (ms)\nΔθ_initial::Real: Phase added to θ before any phase-cycling increment has been applied\nΔθ::Ref{<:Real}: Phase to be added to θ; can be updated to simulate phase-cycling/RF spoiling\ngrad: Gradient applied during the RF pulse\n::Gradient: Constant gradient\n::Vector{<:Gradient}: Time-varying gradient\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.RFSpoiling","page":"Methods","title":"BlochSim.RFSpoiling","text":"RFSpoiling(Δθ = 117°) <: AbstractSpoiling\n\nRepresents RF spoiling, i.e., quadratically incrementing the phase of the RF pulses from TR to TR.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.RFandGradientSpoiling","page":"Methods","title":"BlochSim.RFandGradientSpoiling","text":"RFandGradientSpoiling(grad_spoiling, rf_spoiling) <: AbstractSpoiling\n\nRepresents both RF and gradient spoiling.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.SPGRBlochSim","page":"Methods","title":"BlochSim.SPGRBlochSim","text":"spgr! = SPGRBlochSim(TR, TE, rf, [spoiling], [nTR], [save_transients])\nspgr!(spin, [workspace])\n\nSimulate a spoiled gradient-recalled echo (SPGR) scan on spin, overwriting the spin's magnetization vector. The resultant magnetization is stored in spin.M. If nTR > 0 and save_transients === true, then spgr!(...) returns a Vector with the magnetization vectors at the echo time for each of the nTR simulated TRs.\n\nArguments\n\nTR::Real: Repetition time (ms)\nTE::Real: Echo time (ms)\nrf:\n::Real: Excitation flip angle (rad) (assumes an instantaneous RF pulse)\n::AbstractRF: Excitation RF pulse\nspoiling::AbstractSpoiling = IdealSpoiling(): Type of spoiling to apply\nnTR::Val = Val(0): Number of TRs to simulate; Val(0) indicates to simulate a steady-state scan\nsave_transients::Val = Val(false): Whether or not to return the magnetization vectors at the TE for each of the nTR simulated TRs; does nothing if nTR == 0\n\nworkspace isa SPGRBlochSimWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.Spin","page":"Methods","title":"BlochSim.Spin","text":"Spin([M], M0, T1, T2, Δf, [pos]) <: AbstractSpin\n\nCreate an object that represents a single spin.\n\nProperties\n\nM::Magnetization = Magnetization(0, 0, M0): Magnetization vector\nM0::Real: Equilibrium magnetization\nT1::Real: Spin-lattice recovery time constant (ms)\nT2::Real: Spin-spin recovery time constant (ms)\nΔf::Real: Off-resonance frequency (Hz)\npos::Position = Position(0, 0, 0): Spatial location (cm)\nN::Int = 1: Number of compartments\n\nExamples\n\njulia> Spin(1, 1000, 100, 0, Position(1, 2, 3))\nSpin{Float64}:\n M = Magnetization(0.0, 0.0, 1.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 0.0 Hz\n pos = Position(1.0, 2.0, 3.0) cm\n\njulia> Spin(Magnetization(1, 2, 3), 1, 1000, 100, 0)\nSpin{Float64}:\n M = Magnetization(1.0, 2.0, 3.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 0.0 Hz\n pos = Position(0.0, 0.0, 0.0) cm\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.SpinMC","page":"Methods","title":"BlochSim.SpinMC","text":"SpinMC([M], M0, frac, T1, T2, Δf, τ, [pos]) <: AbstractSpin\n\nCreate an object that represents a single spin with multiple compartments.\n\nProperties\n\nM::MagnetizationMC = Meq: Magnetization vector\nMeq::MagnetizationMC = MagnetizationMC((0, 0, frac[1] * M0), ...): Equilibrium magnetization vector\nM0::Real: Equilibrium magnetization\nfrac::Tuple{<:Real}: Water fraction of each compartment\nT1::Tuple{<:Real}: Spin-lattice recovery time constants (ms)\nT2::Tuple{<:Real}: Spin-spin recovery time constants (ms)\nΔf::Tuple{<:Real}: Off-resonance frequencies (Hz)\nr::Tuple{Tuple{<:Real}}: Exchange rates (1/ms); r[i][j] is the exchange rate from compartment i to compartment j\npos::Position = Position(0, 0, 0): Spatial location (cm)\nN::Int = length(frac): Number of compartments\n\nNote\n\nThe SpinMC constructor takes τ (inverse exchange rate, or residence time) as input, not r. Furthermore, τ is given as a Tuple with N^2 - N elements, arranged like (τ12, τ13, ..., τ1N, τ21, τ23, ..., τ2N, ...).\n\nExamples\n\njulia> SpinMC(1, (0.2, 0.8), (400, 1000), (20, 100), (15, 0), (100, 25))\nSpinMC{Float64,2}:\n M = MagnetizationMC((0.0, 0.0, 0.2), (0.0, 0.0, 0.8))\n M0 = 1.0\n frac = (0.2, 0.8)\n T1 = (400.0, 1000.0) ms\n T2 = (20.0, 100.0) ms\n Δf = (15.0, 0.0) Hz\n r = ((0.0, 0.01), (0.04, 0.0)) 1/ms\n pos = Position(0.0, 0.0, 0.0) cm\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.bSSFPmode","page":"Methods","title":"BlochSim.bSSFPmode","text":"bSSFPmode\n\nA type used to control how bSSFP signal is calculated.\n\nbSSFPbloch use BlochSim matrix computations (default)\nbSSFPellipse use ellipse model for 1-pool\n\n\n\n\n\n","category":"type"},{"location":"methods/#BlochSim.absolutesum-Tuple{BlochSim.BlochDynamicsMatrix}","page":"Methods","title":"BlochSim.absolutesum","text":"absolutesum(A)\n\nCompute the sum of the absolute values of the elements of A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.add!-Tuple{AbstractVector, Magnetization, Magnetization}","page":"Methods","title":"BlochSim.add!","text":"add!(C, A, B)\n\nCompute A + B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.add!-Tuple{Magnetization, Magnetization}","page":"Methods","title":"BlochSim.add!","text":"add!(A, B)\n\nCompute A + B, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.applydynamics!-Tuple{AbstractSpin, Any, Any, Any}","page":"Methods","title":"BlochSim.applydynamics!","text":"applydynamics!(spin, BtoM, A, [B])\n\nApply dynamics to the given spin, overwriting the spin's magnetization vector. BtoM is used to store intermediate results (and is thus overwritten).\n\nExamples\n\njulia> s = Spin(1, 1000, 100, 3.75); s.M\nMagnetization vector with eltype Float64:\n Mx = 0.0\n My = 0.0\n Mz = 1.0\n\njulia> BtoM = Magnetization();\n\njulia> (A,) = excite(s, InstantaneousRF(π/2)); applydynamics!(s, BtoM, A); s.M\nMagnetization vector with eltype Float64:\n Mx = 1.0\n My = 0.0\n Mz = 6.123233995736766e-17\n\njulia> (A, B) = freeprecess(s, 100); applydynamics!(s, BtoM, A, B); s.M\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404054\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.bssfp","page":"Methods","title":"BlochSim.bssfp","text":"bssfp(spin, spin_no_rf_phase_fact, TR_ms, TE_ms, α_rad, θ_rf_rad=0)\nbssfp(spin, spin_no_rf_phase_fact, TR_ms, TE_ms, rf)\n\nReturn steady-state magnetization signal value at the echo time for a phase-cycled bSSFP sequence using BlochSim.\n\nRef: Murthy, N., Nielsen, J. F., Whitaker, S. T., Haskell, M. W., Swanson, S. D., Seiberlich, N., & Fessler, J. A. (2022). Quantifying myelin water exchange using optimized bSSFP sequences. In Proc. Intl. Soc. Mag. Res. Med (p. 2068). [2]\n\nIn (tissue)\n\n'spin' multi-compartment spin object with RF phase cycling factor\n'spinnorfphasefact' multi-compartment spin object without RF phase cycling factor\n\nIn (scan)\n\nTR_ms repetition time (ms)\nTE_ms echo time (ms)\nα_rad flip angle of RF pulse (radians)\nθ_rf_rad phase angle of RF pulse (radians) [default 0]\n\nOr instead provide\n\nrf::AbstractRF\n\nOut\n\nsignal steady-state magnetization (as a complex number)\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.bssfp-2","page":"Methods","title":"BlochSim.bssfp","text":"bssfp(bSSFPellipse, Mz0, T1_ms, T2_ms, Δf_Hz,\n   TR_ms, TE_ms, Δϕ_rad, α_rad, θ_rf_rad=0)\n\nElliptical signal model for bSSFP. This is the analytical solution to the 1-pool bSSFP signal.\n\nXiang et al. MRM 2014; https://doi.org/10.1002/mrm.25098\n\nKeskin et al. IEEE T-MI 2022; https://doi.org/10.1109/TMI.2021.3102852\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.bssfp-Tuple{Any, Number, Number, AbstractRF}","page":"Methods","title":"BlochSim.bssfp","text":"function bssfp(spin, TR_ms, TE_ms, rf::AbstractRF)\n\nClassic version with no phase cycling increment, for InstantaneousRF only.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.bssfp-Tuple{Any, Number, Number, Number, AbstractRF}","page":"Methods","title":"BlochSim.bssfp","text":"function bssfp(spin, TR_ms, TE_ms, Δϕ_rad, rf::AbstractRF)\n\nSignal accounting for  phase cycling increment Δϕ_rad, allowing for finite duration rf pulse.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.bssfp-Tuple{BlochSim.bSSFPmode{:Bloch}, Vararg{Any}}","page":"Methods","title":"BlochSim.bssfp","text":"bssfp(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, α_rad, θ_rf_rad=0)\nbssfp(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, rf, [pos])\nbssfp(spin, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, rf)\n\nReturn steady-state magnetization signal value at the echo time for a bSSFP sequence using BlochSim.\n\nThis generalizes Hargreaves et al., MRM 2001 by accounting for finite RF duration.\n\nIn (tissue parameters):\n\nMz0 initial condition for magnetization in the z-direction (constant)\nT1_ms MRI tissue parameter for T1 relaxation (ms)\nT2_ms MRI tissue parameter for T2 relaxation (ms)\nΔf_Hz off-resonance value (Hz)\n\nIn (scan parameters):\n\nTR_ms repetition time (ms)\nTE_ms echo time (ms), measured from middle of RF pulse\nΔϕ_rad RF phase cycling increment (radians)\nα_rad flip angle of RF pulse (radians)\nθ_rf_rad phase of RF pulse (radians)\n\nOr, instead of α_rad and θ_rf_rad, provide:\n\nrf::AbstractRF, e.g., InstantaneousRF(α_rad, θ_rf_rad)\n\nOption:\n\npos::Position = Position(0.0, 0.0, 0.0) option if rf specified\n\nOut\n\nsignal steady-state transverse magnetization (as a complex number)\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.bssfp-Tuple{Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Number, Vararg{Any}}","page":"Methods","title":"BlochSim.bssfp","text":"bssfp(...)\n\nVersion with scalar arguments (convenient for autodiff)\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.combine!-NTuple{6, Any}","page":"Methods","title":"BlochSim.combine!","text":"combine!(A, B, A1, B1, A2, B2)\ncombine!(A, A1, A2)\n\nCombine the matrices and vectors that describe the dynamics of a spin into one matrix and one vector, overwriting A and B. The dynamics described by A1 and B1 apply first, then those described by A2 and B2. In other words, A = A2 * A1 and B = A2 * B1 + B2.\n\nExamples\n\njulia> s = Spin(1, 1000, 100, 3.75);\n\njulia> A = BlochMatrix(); B = Magnetization();\n\njulia> (A1, B1) = excite(s, InstantaneousRF(π/2));\n\njulia> (A2, B2) = freeprecess(s, 100);\n\njulia> combine!(A, B, A1, B1, A2, B2); A * s.M + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404054\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.div!-Tuple{Magnetization, Any}","page":"Methods","title":"BlochSim.div!","text":"div!(A, a)\n\nCompute A / a, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.duration-Tuple{InstantaneousRF}","page":"Methods","title":"BlochSim.duration","text":"duration(rf)\n\nReturn the duration (ms) of the RF pulse.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.excite","page":"Methods","title":"BlochSim.excite","text":"excite(spin, rf::InstantaneousRF, [nothing])\nexcite(spin, rf::RF, [workspace])\n\nSimulate excitation for the given spin. Returns (A, B) such that A * M + B applies excitation to the magnetization M. If isnothing(B) (as is the case for InstantaneousRFs), then A * M applies excitation to M.\n\nFor RF objects, workspace isa ExcitationWorkspace. For SpinMC objects, use workspace = ExcitationWorkspace(spin, nothing) to use an approximate matrix exponential to solve the Bloch-McConnell equation.\n\nFor an in-place version, see excite!.\n\nExamples\n\njulia> s = Spin(1, 1000, 100, 3.75); s.M\nMagnetization vector with eltype Float64:\n Mx = 0.0\n My = 0.0\n Mz = 1.0\n\njulia> (A,) = excite(s, InstantaneousRF(π/2, π/4)); A * s.M\nMagnetization vector with eltype Float64:\n Mx = 0.7071067811865476\n My = -0.7071067811865475\n Mz = 6.123233995736766e-17\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.excite!-Tuple{AbstractSpin, Vararg{Any}}","page":"Methods","title":"BlochSim.excite!","text":"excite!(spin, ...)\n\nApply excitation to the given spin, overwriting the spin's magnetization vector.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.excite!-Tuple{ExcitationMatrix, AbstractSpin, InstantaneousRF}","page":"Methods","title":"BlochSim.excite!","text":"excite!(A, [nothing], spin, rf::InstantaneousRF, [nothing])\nexcite!(A, B, spin, rf::RF, [workspace])\n\nSimulate excitation, overwriting A and B (in-place version of excite).\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.expm!-Union{Tuple{M}, Tuple{N}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}}, Tuple{BlochMcConnellMatrix{T1, N}, BlochSim.BlochMcConnellDynamicsMatrix{T2, N, M}, BlochSim.MatrixExponentialWorkspace{T3, N}}} where {T1, T2, T3, N, M}","page":"Methods","title":"BlochSim.expm!","text":"expm!(expA, A, [workspace])\n\nCompute the matrix exponential of A, storing it in expA.\n\nworkspace isa MatrixExponentialWorkspace.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.freeprecess","page":"Methods","title":"BlochSim.freeprecess","text":"freeprecess(spin, t, [nothing])\nfreeprecess(spinmc, t, [workspace])\nfreeprecess(spin, t, grad, [nothing])\nfreeprecess(spinmc, t, grad, [workspace])\n\nSimulate free-precession for the given spin for time t ms, optionally in the presence of a B0 gradient. Returns (A, B) such that A * M + B applies free-precession to the magnetization M.\n\nFor SpinMC objects, workspace isa BlochMcConnellWorkspace. Pass in nothing instead to use an approximate matrix exponential to solve the Bloch-McConnell equation.\n\nFor an in-place version, see freeprecess!.\n\nExamples\n\njulia> s = Spin(Magnetization(1, 0, 0), 1, 1000, 100, 3.75)\nSpin{Float64}:\n M = Magnetization(1.0, 0.0, 0.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 3.75 Hz\n pos = Position(0.0, 0.0, 0.0) cm\n\njulia> (A, B) = freeprecess(s, 100); A * s.M + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404048\n\njulia> s = Spin(Magnetization(1, 0, 0), 1, 1000, 100, 0, Position(0, 0, 3.75))\nSpin{Float64}:\n M = Magnetization(1.0, 0.0, 0.0)\n M0 = 1.0\n T1 = 1000.0 ms\n T2 = 100.0 ms\n Δf = 0.0 Hz\n pos = Position(0.0, 0.0, 3.75) cm\n\njulia> (A, B) = freeprecess(s, 100, Gradient(0, 0, 1/GAMBAR)); A * s.M + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404048\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.freeprecess!-NTuple{7, Any}","page":"Methods","title":"BlochSim.freeprecess!","text":"freeprecess!(A, B, t, M0, T1, T2, Δf)\nfreeprecess!(A, B, spin, t, [nothing])\nfreeprecess!(A, B, spinmc, t, [workspace])\nfreeprecess!(A, B, spin, t, grad, [nothing])\nfreeprecess!(A, B, spinmc, t, grad, [workspace])\n\nSimulate free-precession, overwriting A and B (in-place version of freeprecess).\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.freeprecess!-Tuple{AbstractSpin, Vararg{Any}}","page":"Methods","title":"BlochSim.freeprecess!","text":"freeprecess!(spin, ...)\n\nApply free-precession to the given spin, overwriting the spin's magnetization vector.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.freeprecess-NTuple{5, Real}","page":"Methods","title":"BlochSim.freeprecess","text":"freeprecess(t, M0, T1, T2, Δf)\n\nSimulate free-precession, i.e., relaxation and off-resonance precession. Returns (A, B) such that A * M + B applies free-precession to the magnetization M.\n\nFor an in-place version, see freeprecess!.\n\nArguments\n\nt::Real: Duration of free-precession (ms)\nM0::Real: Equilibrium magnetization\nT1::Real: Spin-lattice recovery time constant (ms)\nT2::Real: Spin-spin recovery time constant (ms)\nΔf::Real: Off-resonance frequency (Hz)\n\nExamples\n\njulia> (A, B) = freeprecess(100, 1, 1000, 100, 3.75); A * Magnetization(1, 0, 0) + B\nMagnetization vector with eltype Float64:\n Mx = -0.2601300475114444\n My = -0.2601300475114445\n Mz = 0.09516258196404048\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.get_Δf_tuple-NTuple{4, Any}","page":"Methods","title":"BlochSim.get_Δf_tuple","text":"get_Δf_tuple(Δϕ_rad, Δf0_Hz, Δf_myelin_Hz, TR_ms)\n\nAccount for phase cycling increments as an effective frequency shift\n\nIn:\n\nΔϕ_rad RF phase cycling value (radians)\nΔf0_Hz off-resonance value (Hz)\nΔf_myelin_Hz # additional off-resonance value only experienced by myelin water (Hz)\nTR_ms repetition time (ms)\n\nOut:\n\nΔf_tuple_Hz tuple with off-resonance values for fast and slow compartments\n\nHinshaw, J. Appl. Phys. 1976.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.get_τ_tuple-Tuple{Any, Any}","page":"Methods","title":"BlochSim.get_τ_tuple","text":"get_τ_tuple(τ_fs_ms, f_f)\n\nIn:\n\nτ_fs_ms residence time for exchange from myelin to non-myelin water (ms)\nf_f fast fraction (myelin fraction)\n\nOut:\n\nτ_tuple_ms tuple with fast-to-slow and slow-to-fast residence times\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.gradient_frequency-Tuple{Gradient, Position}","page":"Methods","title":"BlochSim.gradient_frequency","text":"gradient_frequency(grad, pos)\n\nCompute the off-resonance frequency in Hz induced by the given B0 gradient grad at position pos.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.muladd!-Tuple{Magnetization, BlochMatrix, Magnetization}","page":"Methods","title":"BlochSim.muladd!","text":"muladd!(C, A, B)\n\nCompute A * B + C, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.rfspoiling_increment-Tuple{AbstractSpoiling}","page":"Methods","title":"BlochSim.rfspoiling_increment","text":"rfspoiling_increment(spoiling)\n\nReturn the quadratic phase increment used for RF spoiling.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.rotatetheta","page":"Methods","title":"BlochSim.rotatetheta","text":"rotatetheta(α::Real = π/2, θ::Real = 0)\n\nReturn a 3 × 3 BlochMatrix for (left-handed) flip angle α about an axis in the x-y plane that makes (left-handed) angle θ with the negative y-axis.\n\nFor an in-place version, see rotatetheta!.\n\nExamples\n\njulia> BlochSim.rotatetheta() * Magnetization(0, 0, 1) # Rotate towards positive x-axis\nMagnetization vector with eltype Float64:\n Mx = 1.0\n My = 0.0\n Mz = 6.123233995736766e-17\n\njulia> BlochSim.rotatetheta(π/2, π/2) * Magnetization(0, 0, 1) # Rotate towards negative y-axis\nMagnetization vector with eltype Float64:\n Mx = 6.123233995736766e-17\n My = -1.0\n Mz = 6.123233995736766e-17\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.rotatetheta!-Tuple{Any, Any, Any}","page":"Methods","title":"BlochSim.rotatetheta!","text":"rotatetheta!(A, α, θ)\n\nSimulate left-handed rotation by angle α about an axis in the x-y plane that makes left-handed angle θ with the negative y-axis, overwriting A.\n\nThis function is an in-place version of rotatetheta.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.signal-Tuple{Magnetization}","page":"Methods","title":"BlochSim.signal","text":"signal(spin)\nsignal(M)\n\nReturn the signal detected from the given spin or magnetization vector.\n\nExamples\n\njulia> signal(Spin(Magnetization(1, 2, 3), 1, 1000, 100, 0))\n1.0 + 2.0im\n\njulia> signal(MagnetizationMC((1, 2, 3), (1, 1, 1)))\n2 + 3im\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.spoil","page":"Methods","title":"BlochSim.spoil","text":"spoil(spin, spoiling, [nothing])\nspoil(spinmc, spoiling, [workspace])\n\nSimulate gradient or ideal spoiling for the given spin. Returns (A, B), such that A * M + B applies spoiling to the magnetization M. If B is nothing (as is the case for IdealSpoiling), then A * M applies spoiling, and if both A and B are nothing (as is the case for RFSpoiling) then there is no spoiling.\n\nFor SpinMC objects and for GradientSpoiling and RFandGradientSpoiling, workspace isa BlochMcConnellWorkspace. Pass in nothing instead to use an approximate matrix exponential to solve the Bloch-McConnell equation.\n\nNote\n\nThis function only simulates gradient or ideal spoiling, not RF spoiling. RF spoiling must be implemented by updating the phase of the RF pulse(s) in your sequence from TR to TR.\n\nFor an in-place version, see spoil!. ```\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.spoil!","page":"Methods","title":"BlochSim.spoil!","text":"spoil!(A, B, spin, spoiling, [nothing])\nspoil!(A, B, spinmc, spoiling, [workspace])\n\nSimulate gradient or ideal spoiling, overwriting A and B (in-place version of spoil).\n\n\n\n\n\n","category":"function"},{"location":"methods/#BlochSim.spoil!-Union{Tuple{Spin{T}}, Tuple{T}} where T","page":"Methods","title":"BlochSim.spoil!","text":"spoil!(spin)\n\nApply ideal spoiling to the given spin.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.spoiler_gradient-Tuple{GradientSpoiling}","page":"Methods","title":"BlochSim.spoiler_gradient","text":"spoiler_gradient(spoiling)\n\nGet the Gradient object used for gradient spoiling.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.spoiler_gradient_duration-Tuple{AbstractSpoiling}","page":"Methods","title":"BlochSim.spoiler_gradient_duration","text":"spoiler_gradient_duration(spoiling)\n\nReturn the duration of the spoiler gradient (ms).\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtract!-Tuple{Magnetization, Magnetization}","page":"Methods","title":"BlochSim.subtract!","text":"subtract!(A, B)\n\nCompute A - B, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtract!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, LinearAlgebra.UniformScaling, BlochMatrix}} where T","page":"Methods","title":"BlochSim.subtract!","text":"subtract!(C, A, B)\n\nCompute A - B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtractmul!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}","page":"Methods","title":"BlochSim.subtractmul!","text":"subtractmul!(C, X, A, B)\n\nCompute (X - A) * B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#BlochSim.subtractmuladd!-Tuple{Magnetization, Nothing, BlochMatrix, Magnetization}","page":"Methods","title":"BlochSim.subtractmuladd!","text":"subtractmuladd!(C, X, A, B)\n\nCompute (X - A) * B + C, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearAlgebra.mul!-Tuple{Magnetization, Any}","page":"Methods","title":"LinearAlgebra.mul!","text":"mul!(A, a)\n\nCompute A * a, storing the result in A.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearAlgebra.mul!-Tuple{Magnetization, BlochMatrix, Magnetization}","page":"Methods","title":"LinearAlgebra.mul!","text":"mul!(C, A, B)\n\nCompute A * B, storing the result in C.\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/#01-bssfp","page":"bSSFP","title":"bSSFP","text":"This page illustrates using the Julia package BlochSim to calculate MRI signals for balanced steady-state free precession (bSSFP) pulse sequences.\n\nThis demo facilitates understanding bSSFP sequences, multi-compartment spins, and myelin water exchange.\n\nThis demo recreates Figure 3 from [1] and Figure 2 from [2].","category":"section"},{"location":"generated/examples/01-overview/#References","page":"bSSFP","title":"References","text":"[1] Hargreaves, B., Vasanawala, S., Pauly, J., & Nishimura, D. (2001). Characterization and reduction of the transient response in steady‐state MR imaging. MRM 46(1), 149-158.\n[2] Murthy, N., Nielsen, J., Whitaker, S., Haskell, M., Swanson, S., Seiberlich, N., & Fessler, J. (2022). Quantifying myelin water exchange using optimized bSSFP sequences. Proc. Intl. Soc. Mag. Res. Med (#2068).\n[3] Hinshaw, W. S. (1976). Image formation by nuclear magnetic resonance: the sensitive‐point method. J. of Applied Physics, 47(8), 3709-21.\n[4] Whitaker, S. T., Nataraj, G., Nielsen, J. F., & Fessler, J. A. (2020). Myelin water fraction estimation using small‐tip fast recovery MRI. MRM 84(4), 1977-90.\n\nThis page comes from a single Julia file: 01-overview.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"section"},{"location":"generated/examples/01-overview/#Setup","page":"bSSFP","title":"Setup","text":"First we add the Julia packages that are need for this demo. Change false to true in the following code block if you are using any of the following packages for the first time.\n\nif false\n    import Pkg\n    Pkg.add([\n        \"BlochSim\"\n        \"ForwardDiff\"\n        \"LaTeXStrings\"\n        \"LinearAlgebra\"\n        \"MIRTjim\"\n        \"Plots\"\n    ])\nend\n\nTell this Julia session to use the following packages for this example. Run Pkg.add() in the preceding code block first, if needed.\n\nusing BlochSim: Spin, SpinMC, InstantaneousRF, RF, excite, freeprecess\nusing BlochSim: bssfp, bSSFPellipse, GAMMA\nimport ForwardDiff\nusing InteractiveUtils: versioninfo\nusing LaTeXStrings: latexstring\nusing LinearAlgebra: Diagonal, I, cond, diag, norm\nusing MIRTjim: prompt\nusing Plots: gui, plot, plot!, default\ndefault(titlefontsize = 10, markerstrokecolor = :auto, label=\"\", width = 1.5)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() || prompt(:draw);\nnothing #hide\n\nDefine some useful helper functions.\n\nHz_to_kHz(Δf_Hz) = Δf_Hz * 10^(-3) # convert frequencies in Hz to kHz\nkHz_to_Hz(Δf_kHz) = Δf_kHz * 10^(3); # convert frequencies in kHz to Hz\nnothing #hide\n\nThe bSSFP pulse sequence in Figure 2 in [1] starts with a RF pulse, then\n\na is at time TE\nb is TR-TE later, right before next RF pulse\nc is immediately after the next RF pulse\nd is TE after that next RF pulse\n\nWe use this to generate Figure 3 in [1] in two different ways. The RF excitation is repeated periodically and, in steady-state, the magnetization at point a is the same as at point d.","category":"section"},{"location":"generated/examples/01-overview/#Method-1:-Use-matrices","page":"bSSFP","title":"Method 1: Use matrices","text":"Use Equations 1 and 2 and Appendix A from [1]\n\nCalculate the steady-state value at point d using the method from [1] using Equations 1 and 2 and Appendix A.\n\n\"\"\"\n    bssfp_matrix(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, α_rad, θ_rf_rad=0)\n)\n\nReturn steady-state magnetization signal value\nat the echo time\nfor a bSSFP sequence\nusing method of\n[Hargreaves et al., MRM 2001](https://doi.org/10.1002/mrm.1170).\n\n# In tissue:\n- `Mz0` initial condition for magnetization in the z-direction (constant)\n- `T1_ms` MRI tissue parameter for T1 relaxation (ms)\n- `T2_ms` MRI tissue parameter for T2 relaxation (ms)\n- `Δf_Hz` off-resonance value (Hz) (default 0)\n\n# In scan:\n- `TR_ms` repetition time (ms)\n- `TE_ms` echo time (ms)\n- `α_rad` flip angle of RF pulse (radians)\n- `θ_rf_rad` RF pulse phase (radians) (default 0)\n\n# Out\n- `signal` steady-state magnetization (as a complex number)\n\"\"\"\nfunction bssfp_matrix(\n    Mz0, T1_ms, T2_ms, Δf_Hz,\n    TR_ms, TE_ms, α_rad, θ_rf_rad::Number = 0,\n)\n\n    M0 = [0; 0; Mz0] # initial magnetization vector\n\n    # rotation matrix for RF excitation about the y-axis\n    if θ_rf_rad == 0 # y-axis\n        R = [cos(α_rad) 0 sin(α_rad); 0 1 0; -sin(α_rad) 0 cos(α_rad)]\n    elseif θ_rf_rad == -π/2 # x-axis\n        R = [1 0 0; 0 cos(α_rad) sin(α_rad); 0 -sin(α_rad) cos(α_rad)]\n    else\n        throw(\"θ_rf_rad = $θ_rf_rad not implemented\")\n    end\n\n    # free precession matrix\n    Pz(angle) = [cos(angle) sin(angle) 0 ; -sin(angle) cos(angle) 0 ; 0 0 1]\n    P(τ_ms) = Pz( 2π * Hz_to_kHz(Δf_Hz) * τ_ms ) # angle in radians\n\n    # matrices for T1 and T2 relaxation over a time τ\n    C(E1, E2) = [E2 0 0; 0 E2 0; 0 0 E1]\n    C(τ_ms) = C(exp(-τ_ms / T1_ms), exp(-τ_ms / T2_ms))\n    D(τ_ms) = (I - C(τ_ms)) * [0 ; 0 ; Mz0]\n\n    # matrices for various values of τ\n    P1 = P(TE_ms)\n    P2 = P(TR_ms - TE_ms)\n    C1 = C(TE_ms)\n    C2 = C(TR_ms - TE_ms)\n    d1 = D(TE_ms)\n    d2 = D(TR_ms - TE_ms)\n\n    # matrix A and vector b for steady-state calculation\n    A = P1 * C1 * R * P2 * C2\n    b = P1 * C1 * R * d2 + d1\n\n    Mss = (I - A) \\ b # steady-state magnetization\n\n    return complex(Mss[1], Mss[2]) # return the complex signal\nend;\nnothing #hide","category":"section"},{"location":"generated/examples/01-overview/#Recreate-Figure-3-from-[1]","page":"bSSFP","title":"Recreate Figure 3 from [1]","text":"And compare Method 1 above with Method 2 (using bssfp in BlochSim)\n\nTR_ms, TE_ms = 10, 5 # scan parameters\nMz0, T1_ms, T2_ms = 1, 400, 100 # tissue parameters\n\nnum_off_res_values = 401 # vector of off-resonance values\nΔf_arr_Hz = kHz_to_Hz(range(-1, 1, num_off_res_values) / TR_ms) # 2 periods\n\nflip_ang_arr_deg = [15, 30, 60, 90] # vector of flip angles\n\nθ_rf_rad = 0; # y-axis rotation\nnothing #hide\n\nHelper functions for broadcast:\n\nbssfp_matrix(α_rad, Δf_Hz) = # method 1\n    bssfp_matrix(\n        Mz0, T1_ms, T2_ms, Δf_Hz,\n        TR_ms, TE_ms, α_rad, θ_rf_rad,\n    )\n_bssfp(α_rad, Δf_Hz, Δϕ_rad) = # method 2\n    bssfp(\n        Mz0, T1_ms, T2_ms, Δf_Hz,\n        TR_ms, TE_ms, Δϕ_rad, α_rad, θ_rf_rad,\n    )\n_bssfp_ellipse(α_rad, Δf_Hz, Δϕ_rad) = # method 3\n    bssfp(bSSFPellipse,\n        Mz0, T1_ms, T2_ms, Δf_Hz,\n        TR_ms, TE_ms, Δϕ_rad, α_rad, θ_rf_rad,\n    );\nnothing #hide\n\nCall all bssfp versions for various flip angles and off-resonance values and verify that the calculations match.\n\nsig_matrix = bssfp_matrix.(deg2rad.(flip_ang_arr_deg)', Δf_arr_Hz)\nsig_blochsim = _bssfp.(deg2rad.(flip_ang_arr_deg)', Δf_arr_Hz, 0. #= Δϕ_rad =#)\n@assert sig_matrix ≈ sig_blochsim # yes they match!\n\nsig_ellipse = _bssfp_ellipse.(deg2rad.(flip_ang_arr_deg)', Δf_arr_Hz, 0. #= Δϕ_rad =#)\n@assert sig_matrix ≈ sig_ellipse # yes they match!\n\nPlot 1-pool signal magnitude and phase\n\nlabel = reshape(map(a -> \"α = $(a)°\", flip_ang_arr_deg), 1, :) # row!\np_m = plot(Δf_arr_Hz, abs.(sig_blochsim); label,\n    ylabel = \"Signal Magnitude\")\np_p = plot(Δf_arr_Hz, angle.(sig_blochsim); label,\n    xlabel = \"Resonant Frequency (Hz)\",\n    ylabel = \"Signal Phase\")\npmp = plot(p_m, p_p, layout=(2,1), plot_title = \"bSSFP single pool\",\n    plot_titlefontsize = 13)\n\nprompt()\n\nExplore T1 dependence of bSSFP signal model\n\nT1_ms_arr = range(0.90, 1.1, 3) * T1_ms\nα_deg = 20\nsig_t1 = bssfp.(Mz0, T1_ms_arr', T2_ms, Δf_arr_Hz,\n    TR_ms, TE_ms, 0. #= Δϕ_rad =#, deg2rad(α_deg))\n\nlabel = reshape(map(t -> \"T1 = $t ms\", T1_ms_arr), 1, :) # row!\npt1_m = plot(Δf_arr_Hz, abs.(sig_t1); label,\n    ylabel = \"Signal Magnitude\")\npt1_p = plot(Δf_arr_Hz, angle.(sig_t1); label,\n    xlabel = \"Resonant Frequency (Hz)\",\n    ylabel = \"Signal Phase\")\npt1 = plot(pt1_m, pt1_p, layout=(2,1), plot_title = \"bSSFP single pool for T1\",\n    plot_titlefontsize = 13)\n\nprompt()\n\nhelper functions for CRB\n\nreal_imag(x) = [real(x); imag(x)] # stacker\nsnr2sigma(db::Real, yb::AbstractArray{<:Complex}) =\n    10^(-db/20) * norm(yb) / sqrt(length(yb));\nnothing #hide","category":"section"},{"location":"generated/examples/01-overview/#CRB-for-1-pool-bSSFP","page":"bSSFP","title":"CRB for 1-pool bSSFP","text":"Using arbitrary flip angles and phase cycling increments as scan \"design\"\n\nkappa = 1 # also estimate the B1+ factor\nM0_phase = π/3 # just to make it non-trivial\nx = [M0_phase, Mz0, T1_ms, T2_ms, kappa] # unknowns\nΔf_Hz = -7 # known\n\nΔϕ_rad = (0:7)/8 * 2π\nα_rad = [π/7, π/3]\ntmp = Iterators.product(Δϕ_rad, α_rad)\ndesign = (\n  Δϕ_rad = vec(map(x->x[1], tmp)),\n  α_rad = vec(map(x->x[2], tmp)),\n)\n\nsignal_c = (x) -> cis(x[1] #= M0_phase =#) *\n    bssfp.(x[2:end-1]..., Δf_Hz,\n        TR_ms, TE_ms, design.Δϕ_rad, design.α_rad * x[end] #= kappa =#)\nsignal_ri(x) = real_imag(signal_c(x))\n\n\ndB = 40 # SNR\nσ = snr2sigma(dB, signal_c(x)) # noise level\n\nJacobian\n\njac = ForwardDiff.jacobian(signal_ri, x)\nfish = jac' * jac / σ^2\ncond(fish) # 9e8\n\nCRB and standard deviation:\n\ncrb = inv(fish)\ncrb_std = sqrt.(diag(crb))\ncov1 = round.(crb_std ./ x ; digits=3) # coefficient of variation","category":"section"},{"location":"generated/examples/01-overview/#RF-pulse-duration","page":"bSSFP","title":"RF pulse duration","text":"The preceding calculations were all for hypothetical instantaneous\" RF pulses.\n\nExamine effects of finite RF pulse duration for a spin with a relatively short T2.\n\nMz0, T1_ms, T2_ms, Δf_Hz = 1, 400, 40, 0 # tissue parameters\nTR_ms, TE_ms, α_rad = 8, 4, deg2rad(50) # scan parameters\n\nΔϕ_rad = range(-1,1,101) * π\nrf0 = InstantaneousRF(α_rad)\n_bssfp(Δϕ_rad, rf) = bssfp(Mz0, T1_ms, T2_ms, Δf_Hz, TR_ms, TE_ms, Δϕ_rad, rf);\nnothing #hide\n\nSpecify finite-duration hard (rectangular) RF pulse\n\nGAMMA has units rad/s/G\nTip angle for constant pulse: α_rad = GAMMA * b1_gauss * tRF_s\nso b1_gauss = α_rad / GAMMA / tRF_s\n\ntRF_ms = 1\nwaveform1 = [1] * α_rad / (tRF_ms / 1000) / GAMMA # single sample i.e. instant!\nrf1 = RF(waveform1, tRF_ms)\nsignal0 = map(Δϕ -> _bssfp(Δϕ, rf0), Δϕ_rad)\nsignal1 = map(Δϕ -> _bssfp(Δϕ, rf1), Δϕ_rad)\n@assert signal0 ≈ signal1\n@assert α_rad == rf0.α ≈ only(rf1.α)\n\nPlot\n\nprfm = plot(\n xlabel = \"phase cycling increment Δϕ (rad)\",\n ylabel = \"bSSFP signal mag\",\n)\nprfa = plot(\n xlabel = \"phase cycling increment Δϕ (rad)\",\n ylabel = \"bSSFP signal phase\",\n)\nplot!(prfm, Δϕ_rad, abs.(signal0), label=\"Instantaneous\")\nplot!(prfa, Δϕ_rad, angle.(signal0), label=\"Instantaneous\")\nnw = 1000 # approximately 1μs dwell time\nfor tRF_ms in [1e-2 1 2]\n    waveform2 = ones(nw) * α_rad / (tRF_ms / 1000) / GAMMA\n    rf2 = RF(waveform2, tRF_ms/nw)\n    @assert rf0.α ≈ sum(rf2.α)\n    signal2 = map(Δϕ -> _bssfp(Δϕ, rf2), Δϕ_rad)\n    local label = \"tRF = $tRF_ms ms, nw=$nw\"\n    plot!(prfm, Δϕ_rad, abs.(signal2); label)\n    plot!(prfa, Δϕ_rad, angle.(signal2); label)\nend;\n\nprf = plot(prfm, prfa, layout=(2,1),\n plot_title=\"RF pulse duration effect, T2=$T2_ms (ms)\")","category":"section"},{"location":"generated/examples/01-overview/#Multi-compartment-spins-and-myelin-water-exchange","page":"bSSFP","title":"Multi-compartment spins and myelin water exchange","text":"Generate Figure 2 from [2] using BlochSim. First define some useful helper functions. These functions put the parameters in the correct format for the multi-compartment spin object constructors.\n\n\"\"\"\n- in: `f_f` fast fraction (myelin fraction)\n- out: `mwf_tuple` tuple with fast and slow fractions\n\"\"\"\nget_mwf_tuple(f_f) = (f_f, 1-f_f)\n\n\n\"\"\"\n    get_τ_tuple(τ_fs_ms, f_f)\n# In:\n- `τ_fs_ms` residence time for exchange from myelin to non-myelin water (ms)\n- `f_f` fast fraction (myelin fraction)\n# Out:\n- `τ_tuple_ms` tuple with fast-to-slow and slow-to-fast residence times\n\"\"\"\nfunction get_τ_tuple(τ_fs_ms, f_f)\n    τ_sf_ms = (1-f_f) * τ_fs_ms / f_f\n    return (τ_fs_ms, τ_sf_ms)\nend\n\n\n\"\"\"\n# In:\n- `Δϕ_rad` RF phase cycling value (radians)\n- `Δf0_Hz` off-resonance value (Hz)\n- `Δf_myelin_Hz` # additional off-resonance value only experienced by myelin water (Hz)\n- `TR_ms` repetition time (ms)\n# Out:\n- `Δf_tuple_Hz` tuple with off-resonance values for fast and slow compartments\n\n[Hinshaw, J. Appl. Phys. 1976](https://doi.org/10.1063/1.323136).\n\"\"\"\nfunction get_Δf_tuple(Δϕ_rad, Δf0_Hz, Δf_myelin_Hz, TR_ms)\n\n    # convert the RF phase cycling value to Hz from radians\n    Δϕ_Hz = kHz_to_Hz((Δϕ_rad) / (2π*TR_ms))\n\n    # subtract the RF phase cycling value from the off-resonance value\n    Δf_RF_Hz = Δf0_Hz - Δϕ_Hz\n\n    # add the myelin off-resonance for the myelin term\n    Δf_myelin_RF_Hz = Δf_RF_Hz + Δf_myelin_Hz\n\n    # create and return tuple for the spin object constructor\n    Δf_tuple_Hz = (Δf_myelin_RF_Hz, Δf_RF_Hz)\n    return Δf_tuple_Hz\nend;\nnothing #hide\n\nDefine a function similar to Method 2 above, but for multi-compartment spin objects.\n\n\"\"\"\n    bssfp2(α_deg, TR_ms, TE_ms, spin, spin_no_rf_phase_fact)\n\nReturn steady-state magnetization signal value\nat the echo time\nfor a phase-cycled bSSFP sequence\nusing BlochSim.\n\nRef: Murthy, N., Nielsen, J. F., Whitaker, S. T., Haskell, M. W.,\nSwanson, S. D., Seiberlich, N., & Fessler, J. A. (2022).\nQuantifying myelin water exchange using optimized bSSFP\nsequences. In Proc. Intl. Soc. Mag. Res. Med (p. 2068). [2]\n\n# In\n- `α_deg` flip angle of RF pulse (degrees)\n- `TR_ms` repetition time (ms)\n- `TE_ms` echo time (ms)\n- 'spin' multi-compartment spin object with RF phase cycling factor\n- 'spin_no_rf_phase_fact' multi-compartment spin object without RF phase cycling factor\n\n# Out\n- `signal` steady-state magnetization (as a complex number)\n\"\"\"\nfunction bssfp2(\n    α_deg::Number, TR_ms::Number, TE_ms::Number,\n    spin::SpinMC, spin_no_rf_phase_fact::SpinMC,\n)\n\n    # convert flip angle α from degrees to radians\n    α_rad = deg2rad(α_deg)\n\n    # excite the spin and reshape R to be the correct dimensions for a SpinMC object\n    (R,) = excite(spin, InstantaneousRF(α_rad))\n    R = Matrix(R.A)\n    R = kron(I(2),R)\n\n    # precession/relaxation of the spin for TR\n    (PC_TR_A, PC_TR_B) = freeprecess(spin, TR_ms)\n\n    # precession/relaxation of the spin for TE\n    # assume receiver modulates signal and uses the receiver phase as the RF phase\n    (PC_TE_A, PE_TE_B) = freeprecess(spin_no_rf_phase_fact, TE_ms)\n\n    # calculate A matrix and b vector\n    A = Matrix(PC_TR_A) * R\n    b = Vector(PC_TR_B)\n\n    Mss = (I - A) \\ b # steady-state just before tip down\n    M = R * Mss # magnetization after tip-down\n\n    # steady-state magnetization at the echo time\n    M = Matrix(PC_TE_A) * M + Vector(PE_TE_B)\n\n    return complex(M[1]+M[4], M[2]+M[5]) # return the complex signal\nend;\nnothing #hide\n\nIntermediate helper\n\nfunction bssfp2(\n    Mz0::Number,\n    frac::NTuple{2, Number},\n    T1_ms::NTuple{2, Number},\n    T2_ms::NTuple{2, Number},\n    Δf_Hz::NTuple{2, Number},\n    Δf_no_rf_phase_Hz::NTuple{2, Number},\n    τ_ms::NTuple{2, Number},\n    α_deg::Number, TR_ms::Number, TE_ms::Number,\n)\n\n    # create spin (with and without RF phase-cycling factor)\n    spin = SpinMC(Mz0, frac, T1_ms, T2_ms, Δf_Hz, τ_ms)\nglobal spin1 = spin\n    spin_no_rf_phase = SpinMC(Mz0, frac, T1_ms, T2_ms, Δf_no_rf_phase_Hz, τ_ms)\n\n    return bssfp2(α_deg, TR_ms, TE_ms, spin, spin_no_rf_phase)\nend;\n\n\n\"\"\"\n    bssfp2(...)\nVersion with scalar arguments (convenient for autodiff)\n\"\"\"\nfunction bssfp2(\n    M0_phase::Number, # radians\n    Mz0::Number,\n    f_f::Number,\n    T1_f_ms::Number,\n    T1_s_ms::Number,\n    T2_f_ms::Number,\n    T2_s_ms::Number,\n    τ_fs_ms::Number,\n    Δff_Hz::Number, # fast component frequency shift\n    # system parameter (sometimes known):\n    Δf0_Hz::Number, # B0 off resonance\n    # scan parameters (always known):\n    α_deg::Number, TR_ms::Number, TE_ms::Number,\n    Δϕ_deg::Number, # RF phase cycling value (degrees)\n)\n\n    τ_tuple_ms = get_τ_tuple(τ_fs_ms, f_f) # fast-to-slow and slow-to-fast residence times\n\n    # tuple of values incorporating off-resonance and RF phase cycling for both compartments\n    Δϕ_rad = deg2rad(Δϕ_deg)\n    Δf_tuple_Hz = get_Δf_tuple(Δϕ_rad, Δf0_Hz, Δff_Hz, TR_ms)\n    Δf_tuple_Hz_no_rf_phase = get_Δf_tuple(0, Δf0_Hz, Δff_Hz, TR_ms)\n\n    return cis(M0_phase) * bssfp2(\n     Mz0,\n     (f_f, 1 - f_f),\n     (T1_f_ms, T1_s_ms),\n     (T2_f_ms, T2_s_ms),\n     Δf_tuple_Hz,\n     Δf_tuple_Hz_no_rf_phase,\n     τ_tuple_ms,\n     α_deg, TR_ms, TE_ms,\n    )\nend;\nnothing #hide\n\nDefine variables to be used in the following plots. Values taken from [2] and [4].\n\nMz0 = 0.77 # initial condition for longitudinal magnetization (constant)\nΔf_myelin_Hz = 5.0 # frequency shift of myelin water\nf_f = 0.15; # myelin water fraction (MWF), fast fraction\n\n# T1 and T2 values\nT1_f_ms = 400 # T1 for fast-relaxing, myelin water compartment\nT1_s_ms = 832 # T1 for slow-relaxing, non-myelin water compartment\n\nT2_f_ms = 20 # T2 for fast-relaxing, myelin water compartment\nT2_s_ms = 80 # T2 for slow-relaxing, non-myelin water compartment\n\nTR_ms, TE_ms = 20, 4; # scan parameters (note: TE = TR/2 would be more logical)\nnothing #hide\n\nGenerate plots similar to Figure 3 from [1] but with three different RF phase cycling factor values: (0, 90, and 180 degrees).\n\nFor this example, choose one exchange rate:\n\nτ_fs = 50.0 # this will be varied in the next plot\n\nflip_ang_arr_deg = [10, 40] # flip angles\n\nΔϕ_arr_deg = [0, 90, 180] # RF phase cycling value (degrees)\n\n# vector of off-resonance values\nnum_samples = 401 # number of samples (resonant frequencies)\nΔf_arr_Hz = kHz_to_Hz(range(-1, 1, num_samples) / TR_ms);\nnothing #hide\n\nBroadcast via map using helper functions\n\nbssfp_mc(Δf0_Hz::Number, Δϕ_deg::Number, α_deg::Number, τ_fs::Number) =\n    bssfp2(0 #= phase =#, Mz0, f_f, T1_f_ms, T1_s_ms, T2_f_ms, T2_s_ms, τ_fs,\n        Δf_myelin_Hz, Δf0_Hz, α_deg, TR_ms, TE_ms, Δϕ_deg)\n\ntmp = Iterators.product(Δf_arr_Hz, Δϕ_arr_deg, flip_ang_arr_deg)\nbssfp_mc(t3::NTuple{3, Any}) = bssfp_mc(t3..., τ_fs) # (Δf_Hz, Δϕ_deg, α_deg)\nsignal_mc = map(bssfp_mc, tmp);\nnothing #hide\n\nPlot 2-pool signals\n\npmcm = plot(ylabel = \"Signal Magnitude\")\npmcp = plot( ylabel = \"Signal Phase\", xlabel = \"Resonant Frequency (Hz)\")\nfor i in 1:size(signal_mc,3), j in 1:size(signal_mc,2)\n    label2 = \"α = $(flip_ang_arr_deg[i])°, Δϕ = $(Δϕ_arr_deg[j])°\"\n    tmp2 = signal_mc[:,j,i]\n    plot!(pmcm, Δf_arr_Hz, abs.(tmp2))\n    plot!(pmcp, Δf_arr_Hz, angle.(tmp2); label = label2)\nend\n\np2 = plot(pmcm, pmcp, layout = (2,1), titlefontsize = 12,\n    plot_title = \"bSSFP 2-pool magnitude and phase\")\n\nprompt()","category":"section"},{"location":"generated/examples/01-overview/#Recreate-Figure-2-(magnitude-plot)-from-[2]","page":"bSSFP","title":"Recreate Figure 2 (magnitude plot) from [2]","text":"and also plot the phase.\n\nΔf_Hz = 0.0 # set off-resonance to zero for this plot\ntau_arr_ms = [250, 150, 50] # array of exchange values\ntau_arr_marker = [:circle, :star5, :utriangle]\n\nΔϕ_design_deg = ( # designed RF phase cycling increments\n [-176.4, -159.5, -142.1, -124.4, -107.6, -90.54, -73.62, -56.13, -39.41, -22.52, -5.272, 11.63, 28.93, 45.76, 63.08, 79.91, 96.97, 113.9, 131.3, 148.5, 166.1],\n [-168.8, -150.3, -130.1, -111.5, -93.19, -74.18, -54.68 , -37.15, -18.01, 1.342, 18.82, 38.64, 57.88, 76.48, 95.2, 113.3, 133.3, 153.1, 172.1],\n)\n\nα_arr_deg = [10.0, 40.0] # flip angles for plot\nα_design_deg = [\n  fill(α_arr_deg[1], length(Δϕ_design_deg[1]));\n  fill(α_arr_deg[2], length(Δϕ_design_deg[2]))\n]\ndesign = (Δϕ_deg = vcat(Δϕ_design_deg...), α_deg = α_design_deg)\nnum_scans = length(design.Δϕ_deg) # number of different scans = 40\n\ntmp = (τ_fs) -> (Δϕ_deg, α_deg) -> bssfp_mc(Δf_Hz, Δϕ_deg, α_deg, τ_fs)\nbssfp_signal(τ_fs) = map(splat(tmp(τ_fs)), zip(design...))\n\nsignal = bssfp_signal.(tau_arr_ms)\n\n# Plot\nscan_idx = 1:num_scans\np_m = plot(title=\"Signal Magnitude vs. Scan Index\", ylabel = \"Signal Magnitude\")\np_p = plot(title=\"Signal Phase vs. Scan Index\", ylabel = \"Signal Phase\")\nfor j = 1:length(signal) # iterate over exchange values\n    markershape = tau_arr_marker[j]\n    local label = latexstring(\"\\$τ_{\\\\mathrm{fs}}\\$ = $τ_fs ms\")\n    plot!(p_m, scan_idx, abs.(signal[j]), linewidth=0; markershape, label)\n    plot!(p_p, scan_idx, angle.(signal[j]), linewidth=0; markershape, label)\nend\np3 = plot(p_m, p_p, layout = (2,1), xlabel = \"Scan Index\")\n\nprompt()","category":"section"},{"location":"generated/examples/01-overview/#Cramer-Rao-Bound","page":"bSSFP","title":"Cramer-Rao Bound","text":"for the designed scan\n\nkappa = 1 # also estimate the B1+ factor\nM0_phase = π/3 # just to make it non-trivial\nx = [M0_phase, Mz0, f_f, T1_f_ms, T1_s_ms, T2_f_ms, T2_s_ms, τ_fs, Δf_myelin_Hz, kappa] # unknowns\nsignal_c = (x) -> bssfp.(x[1:end-1]..., Δf_Hz, x[end]*design.α_deg, TR_ms, TE_ms, design.Δϕ_deg)\nsignal_ri(x) = real_imag(signal_c(x));\nnothing #hide\n\nNoise level\n\ndB = 40 # SNR\nσ = snr2sigma(dB, signal_c(x))\n\nJacobian\n\njac = ForwardDiff.jacobian(signal_ri, x)\nfish = jac' * jac / σ^2\ncond(fish) # 5e10\n\nThe condition number depends on units, so remove units:\n\nD = Diagonal(1 ./ sqrt.(diag(fish)))\ntmp = D * fish * D\ncond(tmp) # 1e6\n\nCRB and standard deviation:\n\ncrb = inv(fish)\ncrb_std = sqrt.(diag(crb))\n\nCoefficient of variation\n\nround.(crb_std ./ x ; digits=2)","category":"section"},{"location":"generated/examples/01-overview/#Reproducibility","page":"bSSFP","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#BlochSim.jl-Documentation","page":"Home","title":"BlochSim.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This Julia package (BlochSim.jl) provides functionality for simulating MRI pulse sequences.\n\nSee the README and the \"Examples\" for details. In particular, the following blog posts cover the basics of the Bloch equations and some examples of how to use this package.\n\nSimulating MRI Physics with the Bloch Equations\nMastering MRI Bloch Simulations with BlochSim.jl in Julia\nSimulating MRI Scans with BlochSim.jl","category":"section"}]
}
